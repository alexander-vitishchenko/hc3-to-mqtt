{"name":"HC3 <-> MQTT Bridge","type":"com.fibaro.binarySwitch","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_51"},"sections":{"items":[{"components":[{"name":"totalFibaroDevices","style":{"weight":"1.2"},"text":"Total Fibaro devices: -","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"filteredFibaroDevices","style":{"weight":"1.2"},"text":"Filtered devices: -","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"identifiedHaEntities","style":{"weight":"1.2"},"text":"Identified HA entities: -","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"bootTime","style":{"weight":"1.2"},"text":"Boot time: -","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_51"}}},"uiCallbacks":[],"quickAppVariables":[{"name":"mqttUrl","type":"string","value":"mqtt://<host>:1883"},{"name":"mqttKeepAlive","type":"string","value":"60"},{"name":"mqttUsername","type":"string","value":"your_mqtt_username"},{"name":"mqttPassword","type":"string","value":"your_mqtt_password"},{"name":"mqttConvention","type":"string","value":"home-assistant"},{"name":"developmentMode","type":"string","value":"false"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"-- *** FORMATTED LOG %d\n-- *** CHECK AND FIX REMOTE CONTROLER (HEATIT)?  \n-- *** FIX DEVICE ADDED DURING RUNTIME => REMOTE CONTROLLER => NO MQTT MESSAGE?\n\nfunction QuickApp:onInit()\n    self:debug(\"\")\n    self:debug(\"--------------------------------------------------\")\n    self:debug(\"HC3 <-> MQTT BRIDGE\")\n    self:debug(\"Version: 1.0.196\")\n    self:debug(\"(!) IMPORTANT NOTE FOR THOSE USERS WHO USED THE QUICKAPP PRIOR TO 1.0.191 VERSION: Your Home Assistant dashboards and automations need to be reconfigured with new enity ids. This is a one-time effort that introduces a relatively \\\"small\\\" inconvenience for the greater good (a) introduce long-term stability so Home Assistant entity duplicates will not happen in certain scenarios (b) entity id namespaces are now syncronized between Fibaro and Home Assistant ecosystems\")\n    self:debug(\"--------------------------------------------------\")\n    self:debug(\"\")\n\n    self:turnOn()  \nend\n\nfunction QuickApp:publish(topic, payload)\n    self.mqtt:publish(topic, tostring(payload), {retain = true})\nend\n\nfunction QuickApp:turnOn() \n    self:establishMqttConnection()\nend\n\nfunction QuickApp:turnOff()\n    self:disconnectFromMqttAndHc3()\nend\n\nfunction QuickApp:establishMqttConnection() \n    -- IDENTIFY WHICH MQTT CONVENTIONS TO BE USED (e.g. Home Assistant, Homio, etc)\n    self.mqttConventions = { }\n    local mqttConventionStr = self:getVariable(\"mqttConvention\")\n    if (isEmptyString(mqttConventionStr)) then\n        self.mqttConventions[0] = MqttConventionHomeAssistant\n    else\n        local arr = splitString(mqttConventionStr, \",\")\n        for i, j in ipairs(arr) do\n            local convention = mqttConventionMappings[j]\n            if (convention) then\n                self.mqttConventions[i] = clone(convention)\n            end\n        end\n    end\n\n    local mqttConnectionParameters = self:getMqttConnectionParameters()\n    self:trace(\"MQTT Connection Parameters: \" .. json.encode(mqttConnectionParameters))\n\n    local mqttClient = mqtt.Client.connect(\n                                    self:getVariable(\"mqttUrl\"),\n                                    mqttConnectionParameters) \n\n    mqttClient:addEventListener('connected', function(event) self:onConnected(event) end)\n    mqttClient:addEventListener('closed', function(event) self:onClosed(event) end)\n    mqttClient:addEventListener('message', function(event) self:onMessage(event) end)\n    mqttClient:addEventListener('error', function(event) self:onError(event) end)    \n    \n    self.mqtt = mqttClient\nend\n\nfunction QuickApp:getMqttConnectionParameters()\n    local mqttConnectionParameters = {\n        -- pickup last will from primary MQTT Convention provider\n        lastWill = self.mqttConventions[1]:getLastWillMessage()\n    }\n\n    -- MQTT CLIENT ID (OPTIONAL)\n    local mqttClientId = self:getVariable(\"mqttClientId\")\n    if (isEmptyString(mqttClientId)) then\n        local autogeneratedMqttClientId = \"HC3-\" .. plugin.mainDeviceId .. \"-\" .. tostring(os.time())\n        self:debug(\"All is good - mqttClientId has been generated for you automatically \\\"\" .. autogeneratedMqttClientId .. \"\\\"\")\n        mqttConnectionParameters.clientId = autogeneratedMqttClientId\n    else\n        mqttConnectionParameters.clientId = mqttClientId\n    end\n\n    -- MQTT KEEP ALIVE PERIOD\n    local mqttKeepAlivePeriod = self:getVariable(\"mqttKeepAlive\")\n    if (mqttKeepAlivePeriod) then\n        mqttConnectionParameters.keepAlivePeriod = tonumber(mqttKeepAlivePeriod)\n    else\n        mqttConnectionParameters.keepAlivePeriod = 60\n    end\n\n    -- MQTT AUTH (USERNAME/PASSWORD)\n    local mqttUsername = self:getVariable(\"mqttUsername\")\n    local mqttPassword = self:getVariable(\"mqttPassword\")\n\n    if (mqttUsername) then\n        mqttConnectionParameters.username = mqttUsername\n    end\n    if (mqttPassword) then\n        mqttConnectionParameters.password = mqttPassword\n    end\n\n    return mqttConnectionParameters\nend\n\nfunction QuickApp:disconnectFromMqttAndHc3()\n    self.hc3ConnectionEnabled = false\n    self:closeMqttConnection()\nend\n\nfunction QuickApp:closeMqttConnection()\n    for i, j in ipairs(self.mqttConventions) do\n        if (j.mqtt ~= MqttConventionPrototype.mqtt) then\n            j:onDisconnected()\n        end\n    end\n\n    self.mqtt:disconnect()\nend\n\nfunction QuickApp:disconnectFromMqttAndHc3()\n    self.hc3ConnectionEnabled = false\n    self:closeMqttConnection()\nend\n\n\nfunction QuickApp:onClosed(event)\n    self:updateProperty(\"value\", false)\n    self:debug(\"Disconnected from MQTT (Home Assistant)\")\nend\n\nfunction QuickApp:onError(event)\n    self:error(\"MQTT ERROR: \" .. json.encode(event))\n    if event.code == 2 then\n        self:warning(\"MQTT username and/or password is possibly indicated wrongly\")\n    end\n    self:turnOff()\n    self:scheduleReconnectToMqtt();\nend\n\nfunction QuickApp:scheduleReconnectToMqtt()\n    fibaro.setTimeout(10000, function() \n        self:debug(\"Attempt to reconnect to MQTT...\")\n        self:establishMqttConnection()\n    end)\nend\n\nfunction QuickApp:onMessage(event)\n    for i, j in ipairs(self.mqttConventions) do\n        j:onCommand(event)\n    end\nend\n\nfunction QuickApp:onConnected(event) \n    self:debug(\"\")\n    self:debug(\"--------------------------------------------------\")\n    self:debug(\"Connected to MQTT (Home Assistant)\")\n    self:debug(\"--------------------------------------------------\")\n    self:debug(\"\")\n\n    for _, mqttConvention in ipairs(self.mqttConventions) do\n        mqttConvention.mqtt = self.mqtt\n        mqttConvention:onConnected()\n    end\n\n    self:discoverDevicesAndPublishToMqtt()\n\n    self.hc3ConnectionEnabled = true\n    self:scheduleHc3EventsFetcher()\n\n    self:updateProperty(\"value\", true)\nend\n\nfunction QuickApp:discoverDevicesAndPublishToMqtt()\n    local startTime = os.time()\n    local phaseStartTime = startTime\n    local deviceHierarchy = self:discoverDeviceHierarchy()\n    local phaseEndTime = os.time()\n    \n    self:debug(\"\")\n    self:debug(\"-------------------------------------------------\")\n    self:debug(\"Device discovery has been complete in \" .. (phaseEndTime - phaseStartTime) .. \" second(s)\")\n    self:debug(\"Total devices                        : \" .. allFibaroDevicesAmount)\n    self:debug(\"Filtered to                          : \" .. filteredFibaroDevicesAmount)\n    self:debug(\"Number of Home Assistant entities    : \" .. identifiedHaEntitiesAmount .. \" => number of supported Fibaro devices + automatically generated entities for power, energy and battery sensors (when found appropriate interfaces for a Fibaro device) + automatically generated  remote controllers, where cartesian join is applied for each key and press types\")\n    self:debug(\"-------------------------------------------------\")\n    self:debug(\"\")\n    self:printDeviceHierarchy(deviceHierarchy)\n\n    phaseStartTime = os.time()\n    self:publishDeviceHierachyToMqtt(deviceHierarchy)\n    phaseEndTime = os.time()    \n\n    -- *** rework log messages\n    self:debug(\"\")\n    self:debug(\"----------------------------------------------------------------------------\")\n    self:debug(\"Device configuration and states have been distributed to MQTT in \" .. (phaseEndTime - phaseStartTime) .. \" second(s)\")\n    self:debug(\"----------------------------------------------------------------------------\")\n    self:debug(\"\")\n\n\n    local diff = os.time() - startTime\n\n    self:updateView(\"totalFibaroDevices\", \"text\", \"Total Fibaro devices: \" .. allFibaroDevicesAmount)\n    self:updateView(\"filteredFibaroDevices\", \"text\", \"Filtered devices: \" .. filteredFibaroDevicesAmount)\n    self:updateView(\"identifiedHaEntities\", \"text\", \"Identified devices: \" .. identifiedHaEntitiesAmount)\n \n    self:updateView(\"bootTime\" , \"text\", \"Boot time: \" .. diff .. \"s\")\n\nend\n\nfunction QuickApp:discoverDeviceHierarchy()\n\n    local developmentModeStr = self:getVariable(\"developmentMode\")\n    if ((not developmentModeStr) or (developmentModeStr ~= \"true\")) then\n        self:debug(\"Bridge mode: PRODUCTION\")\n\n        local customDeviceFilterJsonStr = self:getVariable(\"deviceFilter\")\n        if (isEmptyString(mqttClientId)) then\n            self:debug(\"All is good - default filter applied, where only enabled and visible devices are used\")\n        end\n\n        fibaroDevices = getDeviceHierarchyByFilter(customDeviceFilterJsonStr)\n    else\n        -- smaller number of devices for development and testing purposes\n        self:debug(\"Bridge mode: DEVELOPMENT\")\n\n        fibaroDevices = {\n            enrichFibaroDeviceWithMetaInfo(\n                json.decode(\n                    \"{  }\"\n                )\n            ) \n        }\n    end\n\n    return fibaroDevices\nend\n\nfunction QuickApp:printDeviceHierarchy(deviceHierarchy)\n    for _, j in pairs(deviceHierarchy) do\n        self:printDeviceNode(j, 1)\n    end\nend\nfunction QuickApp:printDeviceNode(deviceNode, level)\n    local deviceDescription = \"\"\n\n    local lastSiblingNode\n    local lastSiblingNodeOfParent\n    local lastSiblingNodeOfParentOfParent\n    if (deviceNode.parentNode) then\n        local siblingNodes = deviceNode.parentNode.childNodeList\n        lastSiblingNode = siblingNodes[#siblingNodes]\n\n        if (deviceNode.parentNode.parentNode) then\n            local siblingNodesOfParent = deviceNode.parentNode.parentNode.childNodeList\n            lastSiblingNodeOfParent = siblingNodesOfParent[#siblingNodesOfParent]\n\n            if (deviceNode.parentNode.parentNode.parentNode) then\n                local siblingNodesOfParentOfParent = deviceNode.parentNode.parentNode.parentNode.childNodeList\n                lastSiblingNodeOfParentOfParent = siblingNodesOfParentOfParent[#siblingNodesOfParentOfParent]\n            end\n        end\n    end\n\n    if level > 1 then\n        local levelCap = level-1\n        for i=1, levelCap do\n            deviceDescription = deviceDescription .. \"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"\n            \n            if (i > 1) then\n                deviceDescription = deviceDescription .. \"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"\n            end\n            \n            -- *** refactor with dynamic parent level number \n            if (i < levelCap) then\n                if ((i == (levelCap - 2)) and (deviceNode.parentNode ~= lastSiblingNodeOfParentOfParent)) then\n                    deviceDescription = deviceDescription .. \"&#x2503;\"\n                elseif ((i == (levelCap - 1)) and (deviceNode.parentNode ~= lastSiblingNodeOfParent)) then\n                    deviceDescription = deviceDescription .. \"&#x2503;\"\n                else\n                    deviceDescription = deviceDescription .. \"&nbsp;\"\n                end\n            end\n        end\n\n        if (deviceNode == lastSiblingNode) then\n            -- â”—\n            deviceDescription = deviceDescription .. \"&#x2517;\"\n        else\n            -- â”£\n            deviceDescription = deviceDescription .. \"&#9507;\"\n        end\n\n        -- â”â”â–¶\n        deviceDescription = deviceDescription .. \"&#9473;&#9473;&#9654; \"\n    end\n\n    local bracketStart\n    local bracketEnd\n    if (deviceNode.isHaDevice) then\n        -- ã€š  ã€›\n        --bracketStart = \"&#12310;\"\n        --bracketEnd = \"&#12311;\"\n        -- < >\n        bracketStart = \"<\"\n        bracketEnd = \">\"\n    else\n        bracketStart = \"[\"\n        bracketEnd = \"]\"\n    end\n\n    local deviceType\n    if (deviceNode.included) then\n        local identifiedHaEntity = deviceNode.identifiedHaEntity\n\n        if (identifiedHaEntity) then\n            -- ðŸ’¡, ðŸŒˆ, ðŸ”Œ, etc\n            deviceDescription = deviceDescription .. bracketStart .. identifiedHaEntity.icon .. bracketEnd.. \" \"\n            deviceType = identifiedHaEntity.type .. \"-\" .. tostring(identifiedHaEntity.subtype)\n        else\n            -- ðŸš§\n            deviceDescription = deviceDescription .. bracketStart .. \"&#128679;\" .. bracketEnd .. \" \"\n        end\n    else\n        -- ðŸ›‡\n        deviceDescription = deviceDescription .. bracketStart .. \"&#128711;\" .. bracketEnd .. \" \"\n    end\n\n    local fibaroDevice = deviceNode.fibaroDevice\n    \n    deviceDescription = deviceDescription .. \"#\" .. fibaroDevice.id .. \" named as \\\"\"  .. tostring(fibaroDevice.name) .. \"\\\"\"\n\n    if (fibaroDevice.roomName) then\n        deviceDescription = deviceDescription .. \" in \\\"\" .. fibaroDevice.roomName .. \"\\\" room\"\n    end\n\n    if (deviceNode.included) then\n        if (deviceType) then\n            deviceDescription = deviceDescription .. \" identified as \" .. deviceType .. \" type\"\n        else\n            deviceDescription = deviceDescription .. \" (unsupported device: \" .. fibaroDevice.baseType .. \"-\" .. fibaroDevice.type .. \")\"\n        end\n    else\n        deviceDescription = deviceDescription .. \" (excluded by QuickApp filters)\"\n    end\n\n    self:debug(deviceDescription)\n\n    for _, deviceChildNode in pairs(deviceNode.childNodeList) do\n        self:printDeviceNode(deviceChildNode, level + 1)\n    end\n\nend\n\nfunction QuickApp:publishDeviceHierachyToMqtt(deviceHierarchy)\n    for _, deviceNode in pairs(deviceHierarchy) do\n        self:publishDeviceNodeToMqtt(deviceNode)\n    end\nend\nfunction QuickApp:publishDeviceNodeToMqtt(deviceNode)\n    if (deviceNode.identifiedHaEntity) then\n        self:__publishDeviceNodeToMqtt(deviceNode)\n    end\n\n    for _, fibaroDeviceChildNode in pairs(deviceNode.childNodeList) do\n        self:publishDeviceNodeToMqtt(fibaroDeviceChildNode)\n    end\nend\n\n\nfunction QuickApp:discoverDevicesByFilter()\n    local fibaroDevices\n\n    local developmentModeStr = self:getVariable(\"developmentMode\")\n    if ((not developmentModeStr) or (developmentModeStr ~= \"true\")) then\n        self:debug(\"Bridge mode: PRODUCTION\")\n\n        local customDeviceFilterJsonStr = self:getVariable(\"deviceFilter\")\n        if (isEmptyString(mqttClientId)) then\n            self:debug(\"All is good - default filter applied, where only enabled and visible devices are used\")\n        end\n\n\n        fibaroDevices = getFibaroDevicesByFilter(customDeviceFilterJsonStr)\n    else\n        --smaller number of devices for development and testing purposes\n        self:debug(\"Bridge mode: DEVELOPMENT\")\n\n        fibaroDevices = {\n            enrichFibaroDeviceWithMetaInfo(\n                json.decode(\n                    \"{  }\"\n                )\n            ) \n        }\n    end\n\n    return fibaroDevices\nend\n\nfunction QuickApp:__publishDeviceNodeToMqtt(deviceNode)\n    ------------------------------------------------------------------\n    ------- ANNOUNCE DEVICE EXISTANCE\n    ------------------------------------------------------------------\n    for i, j in ipairs(self.mqttConventions) do\n        j:onDeviceNodeCreated(deviceNode)\n    end\n\n    ------------------------------------------------------------------\n    ------- ANNOUNCE DEVICE CURRENT STATE => BY SIMULATING HC3 EVENTS\n    ------------------------------------------------------------------\n    self:__publishDeviceProperties(deviceNode.fibaroDevice)\nend\n\nfunction QuickApp:__publishDeviceProperties(fibaroDevice)\n    self:simulatePropertyUpdate(fibaroDevice, \"dead\", fibaroDevice.properties.dead)\n    self:simulatePropertyUpdate(fibaroDevice, \"state\", fibaroDevice.properties.state)\n    self:simulatePropertyUpdate(fibaroDevice, \"value\", fibaroDevice.properties.value)\n    self:simulatePropertyUpdate(fibaroDevice, \"heatingThermostatSetpoint\", fibaroDevice.properties.heatingThermostatSetpoint)\n    self:simulatePropertyUpdate(fibaroDevice, \"thermostatMode\", fibaroDevice.properties.thermostatMode)\n    self:simulatePropertyUpdate(fibaroDevice, \"energy\", fibaroDevice.properties.energy)\n    self:simulatePropertyUpdate(fibaroDevice, \"power\", fibaroDevice.properties.power)\n    self:simulatePropertyUpdate(fibaroDevice, \"batteryLevel\", fibaroDevice.properties.batteryLevel)\n    self:simulatePropertyUpdate(fibaroDevice, \"color\", fibaroDevice.properties.color)\nend\n\nfunction QuickApp:onPublished(event)\n    -- do nothing, for now\nend\n\n-- FETCH HC3 EVENTS\nlocal lastRefresh = 0\nlocal http = net.HTTPClient()\n\nfunction QuickApp:scheduleHc3EventsFetcher()\n    self:readHc3EventAndScheduleFetcher()\n\n    self:debug(\"\")\n    self:debug(\"--------------------------------------------------\")\n    self:debug(\"Connected to Fibaro Home Center 3\")\n    self:debug(\"--------------------------------------------------\")\n    self:debug(\"\")\nend\n\nfunction QuickApp:readHc3EventAndScheduleFetcher()\n    -- This a reliable and high-performance method to get events from Fibaro HC3, by using non-blocking HTTP calls\n\n    local requestUrl = \"http://127.0.0.1:11111/api/refreshStates?last=\" .. lastRefresh\n    --self:debug(\"Fetch events from \" .. requestUrl .. \" | \" .. tostring(self.hc3ConnectionEnabled))\n\n    local stat, res = http:request(\n        requestUrl,\n        {\n        options = { },\n        success=function(res)\n            local data\n            if (res and not isEmptyString(res.data)) then\n                self:processFibaroHc3Events(json.decode(res.data))\n            else\n                self:error(\"Error while fetching events from Fibaro HC3. Response status code is \" .. res.status .. \". HTTP response body is '\" .. json.encode(res) .. \"'\")\n                self:turnOff()\n            end\n        end,\n        error=function(res) \n            self:error(\"Error while fetching Fibaro HC3 events \" .. json.encode(res))\n            self:turnOff()\n        end\n    })\n\n    if (self.hc3ConnectionEnabled) then\n        local delay\n        if self.gotError then\n            self:warning(\"Got error - retry in 1s\")\n            delay = 1000\n        else\n            delay = 100\n        end\n\n        fibaro.setTimeout(delay, function()\n            self:readHc3EventAndScheduleFetcher()\n        end)\n    else\n        self:debug(\"Disconnected from Fibaro HC3\")\n    end\n\nend\n\nfunction QuickApp:processFibaroHc3Events(data)\n    if not self.hc3ConnectionEnabled then\n        return\n    end\n\n    self.gotError = false\n    if (data.status ~= 200 and data.status ~= \"IDLE\") then\n        self:warning(\"Unexpected response status \" .. tostring(data.status))\n    end\n\n    local events = data.events\n\n    if (data.last) then\n        lastRefresh = data.last\n    end\n\n    if events and #events>0 then \n        for i, v in ipairs(events) do\n            -- *** rename dispatch to \"PROCESS\" / ename onDeviceCreated and so on => \"dispatchToMqtt\"\n            self:dispatchFibaroEventToMqtt(v)\n        end\n    end\nend\n\nfunction QuickApp:simulatePropertyUpdate(fibaroDevice, propertyName, value)\n    if value ~= nil then\n        local event = createFibaroEventPayload(fibaroDevice, propertyName, value)\n        event.simulation = true\n        self:dispatchFibaroEventToMqtt(event)\n    end\nend\n\ndeviceModifiedEventTimestamps = {}\ndeviceCreatedEventTimestamps = {}\nfunction QuickApp:dispatchFibaroEventToMqtt(event)\n    if (not event) then\n        self:error(\"No event found\")\n        return\n    end\n\n    if (not event.data) then\n        self:error(\"No event data found\")\n        return\n    end\n\n    local fibaroDeviceId = event.data.id or event.data.deviceId\n\n    -- *** add origin event source id\n\n    if not fibaroDeviceId then\n        -- This is a system level event, which is not bound to a particular device => ignore\n        return\n    end \n\n    local eventType = event.type\n    if (not eventType) then\n        eventType = \"<unknown>\"\n    end\n\n    local deviceNode = getDeviceNodeById(fibaroDeviceId)\n\n    -- *** REMOVE \n    --print(\"EVENT : \" .. json.encode(event))\n\n    if (deviceNode) then\n        -- process events for devices that are required to be known to the QuickApp\n        if deviceNode.included then\n            -- process events for devices that are included by user filter criteria\n            local haEntity = deviceNode.identifiedHaEntity\n            if haEntity then\n                if (eventType == \"DevicePropertyUpdatedEvent\") then\n                    return self:dispatchDevicePropertyUpdatedEvent(deviceNode, event) \n                elseif (eventType == \"CentralSceneEvent\") then\n                    -- convert to DevicePropertyUpdatedEvent event, so we reuse the existing value dispatch mechanism rather than reinventing a wheel\n                    local keyValueMapAsString = event.data.keyId .. \",\" .. string.lower(event.data.keyAttribute)\n                    self:trace(\"Action => \" .. event.data.keyId .. \"-\" .. string.lower(event.data.keyAttribute))\n                    return self:simulatePropertyUpdate(deviceNode, \"value\", keyValueMapAsString)\n                elseif (eventType == \"DeviceModifiedEvent\") then\n                    -- Fibaro generates \"DeviceModifiedEvent\" event after \"DeviceCreatedEvent\" => filter out the reduntant event \n                    \n                    local deviceLastCreationTimestamp = deviceCreatedEventTimestamps[fibaroDeviceId]\n                    local deviceLastModificationTimestamp = deviceModifiedEventTimestamps[fibaroDeviceId]\n                    if ((deviceLastCreationTimestamp) and (deviceLastCreationTimestamp == event.created)) then\n                        self:debug(\"Ignore duplicate event for 'DeviceModifiedEvent' as it's called right after 'DeviceCreatedEvent'\")\n                        return\n                    elseif ((deviceLastModificationTimestamp) and (deviceLastModificationTimestamp == event.created)) then\n                        self:debug(\"Ignore duplicate event for 'DeviceModifiedEvent' as it's called right after another 'DeviceModifiedEvent'\")\n                        return\n                    else\n                        return self:dispatchDeviceModifiedEvent(deviceNode)\n                    end\n                elseif (eventType == \"DeviceRemovedEvent\") then \n                    return self:dispatchDeviceRemovedEvent(deviceNode)\n                else\n                    -- unsupported event type => ignore\n                    return\n                end\n            else\n                -- event for unsupported device => ignore\n                return\n            end\n        \n        else\n            -- event for a device excluded by user filter criteria => ignore\n            return\n        end\n\n    else \n        -- process events for devices that are NOT REQUIRED to be known to the QuickApp \n        if (eventType == \"DeviceCreatedEvent\") then\n            deviceCreatedEventTimestamps[fibaroDeviceId] = event.created\n            return self:dispatchDeviceCreatedEvent(fibaroDeviceId)\n        else\n            -- ignore unknown devices\n            return\n        end\n    end\n\n    -- Ignore and show no redundant warnings for unsupported event types\n    if (unsupportedFibaroEventTypes[eventType]) then\n        -- Ignore and show no redundant warnings\n        return\n    end\n\n    self:debug(\"Couldn't process event \\\"\" .. eventType .. \"\\\" for \" .. getDeviceDescriptionById(fibaroDeviceId))\n    self:debug(json.encode(event))\nend\n\nfunction QuickApp:dispatchDevicePropertyUpdatedEvent(deviceNode, event)\n    -- *** OVERRIDE FIBARO PROPERTY NAMES, FOR BEING MORE CONSISTENT AND THUS EASIER TO HANDLE \n    local haEntity = deviceNode.identifiedHaEntity\n    local propertyName = event.data.property\n    if not propertyName then\n        propertyName = \"unknown\"\n    end\n\n    if (haEntity.type == \"binary_sensor\") and (propertyName == \"value\") then\n        -- Fibaro uses state/value fields inconsistently for binary sensor. Replace value --> state field\n        event.data.property = \"state\"\n    end\n\n    local value = event.data.newValue\n    if (isNumber(value)) then\n        value = round(value, 2)\n    end\n\n    event.data.newValue = (type(value) == \"number\" and value or tostring(value))\n    \n    for i, j in ipairs(self.mqttConventions) do\n        j:onPropertyUpdated(deviceNode, event)\n    end\nend\n\nfunction QuickApp:rememberLastMqttCommandTime(deviceId)\n    self.lastMqttCommandTime[deviceId] = os.time()\nend\n\nfunction QuickApp:dispatchDeviceCreatedEvent(fibaroDeviceId)\n    local newDeviceNode = createAndAddDeviceNodeToHierarchyById(fibaroDeviceId)\n\n    if (newDeviceNode.included and newDeviceNode.identifiedHaEntity) then\n        self:debug(\"Fibaro device \" .. newDeviceNode.id .. \" added\")\n        for i, j in ipairs(self.mqttConventions) do\n            j:onDeviceNodeCreated(newDeviceNode)\n        end\n        \n        self:__publishDeviceProperties(newDeviceNode.fibaroDevice)\n\n        self:printDeviceNode(newDeviceNode, 1)\n    else\n        self:debug(\"New device \" .. newDeviceNode.id .. \" will not be added\")\n    end\nend\n\nfunction QuickApp:dispatchDeviceModifiedEvent(deviceNode)\n    self:debug(\"Fibaro device \" .. deviceNode.id .. \" got modified => its old configuration to be removed, and then the new one added by the QuickApp\")\n\n    self:dispatchDeviceRemovedEvent(deviceNode)\n\n    self:dispatchDeviceCreatedEvent(deviceNode.id)\nend\n\nfunction QuickApp:dispatchDeviceRemovedEvent(deviceNode)\n    removeDeviceNodeFromHierarchyById(deviceNode.id)\n\n    for _, mqttConvention in ipairs(self.mqttConventions) do\n        mqttConvention:onDeviceNodeRemoved(deviceNode)\n\n        for _, childNode in ipairs(deviceNode.childNodeList) do\n            self:dispatchDeviceRemovedEvent(childNode)\n        end\n\n    end\n    self:debug(\"Fibaro device removed \" .. deviceNode.id)\nend\n\nunsupportedFibaroEventTypes = {\n    DeviceActionRanEvent = true,\n    DeviceChangedRoomEvent = true,\n    QuickAppFilesChangedEvent = true, \n    PluginChangedViewEvent = true\n}"},{"name":"tools","isMain":false,"isOpen":true,"content":"local alphabet = {\r\n    [\"Ð\"] = \"A\",\r\n    [\"Ð‘\"] = \"B\",\r\n    [\"Ð’\"] = \"V\",\r\n    [\"Ð“\"] = \"G\",\r\n    [\"Ð”\"] = \"D\",\r\n    [\"Ð•\"] = \"E\",\r\n    [\"Ð–\"] = \"Zh\",\r\n    [\"Ð—\"] = \"Z\",\r\n    [\"Ð˜\"] = \"I\",\r\n    [\"Ð†\"] = \"I\",\r\n    [\"Ð‡\"] = \"I\",\r\n    [\"Ð™\"] = \"I\",\r\n    [\"Ðš\"] = \"K\",\r\n    [\"Ð›\"] = \"L\",\r\n    [\"Ðœ\"] = \"M\",\r\n    [\"Ð\"] = \"N\",\r\n    [\"Ðž\"] = \"O\",\r\n    [\"ÐŸ\"] = \"P\",\r\n    [\"Ð \"] = \"R\",\r\n    [\"Ð¡\"] = \"S\",\r\n    [\"Ð¢\"] = \"T\",\r\n    [\"Ð£\"] = \"U\",\r\n    [\"Ð¤\"] = \"F\",\r\n    [\"Ð¥\"] = \"H\",\r\n    [\"Ð§\"] = \"Ch\",\r\n    [\"Ð¦\"] = \"C\",\r\n    [\"Ð¨\"] = \"Sh\",\r\n    [\"Ð©\"] = \"Shch\",\r\n    [\"Ð˜\"] = \"I\",\r\n    [\"Ð„\"] = \"E\",\r\n    [\"Ð­\"] = \"E\",\r\n    [\"Ð®\"] = \"Ju\",\r\n    [\"Ð¯\"] = \"Ja\",\r\n    [\"Ð°\"] = \"a\",\r\n    [\"Ð±\"] = \"b\",\r\n    [\"Ð²\"] = \"v\",\r\n    [\"Ð³\"] = \"g\",\r\n    [\"Ð´\"] = \"d\",\r\n    [\"Ðµ\"] = \"e\",\r\n    [\"~\"] = \"e\",\r\n    [\"Ð¶\"] = \"zh\",\r\n    [\"Ð·\"] = \"z\",\r\n    [\"Ð¸\"] = \"i\",\r\n    [\"Ñ–\"] = \"i\",\r\n    [\"Ñ—\"] = \"i\",\r\n    [\"Ð¹\"] = \"i\",\r\n    [\"Ðº\"] = \"k\",\r\n    [\"Ð»\"] = \"l\",\r\n    [\"Ð¼\"] = \"m\",\r\n    [\"Ð½\"] = \"n\",\r\n    [\"Ð¾\"] = \"o\",\r\n    [\"Ð¿\"] = \"p\",\r\n    [\"Ñ€\"] = \"r\",\r\n    [\"Ñ\"] = \"s\",\r\n    [\"Ñ‚\"] = \"t\",\r\n    [\"Ñƒ\"] = \"u\",\r\n    [\"Ñ„\"] = \"f\",\r\n    [\"Ñ…\"] = \"h\",\r\n    [\"Ñ‡\"] = \"ch\",\r\n    [\"Ñ†\"] = \"c\",\r\n    [\"Ñˆ\"] = \"sh\",\r\n    [\"Ñ‰\"] = \"shch\",\r\n    [\"Ñ‹\"] = \"i\",\r\n    [\"ÑŒ\"] = \"'\",\r\n    [\"Ñ”\"] = \"e\",\r\n    [\"Ñ\"] = \"e\",\r\n    [\"ÑŽ\"] = \"ju\",\r\n    [\"Ñ\"] = \"ja\"\r\n}\r\n\r\nfunction transliterate(input)\r\n    if (not input) then\r\n        return \"unknown_input_for_transliteration\"\r\n    end\r\n\r\n    local output = {}\r\n    local i = 1\r\n\r\n    for p, c in utf8.codes(input) do  \r\n        local char = utf8.char(c)\r\n        local outputCharacter = alphabet[char]\r\n\r\n        if not outputCharacter then\r\n        if (string.find(char, \"%a\") or string.find(char, \"%d\")) then\r\n            outputCharacter = char\r\n        else\r\n            outputCharacter = \"-\"\r\n        end\r\n\r\n        end\r\n        output[i] = outputCharacter\r\n        i = i + 1\r\n    end\r\n\r\n    --print(\"RESULT \" .. table.concat(output) ) \r\n\r\n    return table.concat(output) \r\nend\r\n\r\nfunction extractMetaInfoFromDeviceName(deviceName)\r\n    local metaInfo = {\r\n        pureName = deviceName,\r\n        autoPower = true,\r\n        turnOffTimeout = 10 * 60,\r\n        segmentId = -1,\r\n    }\r\n    \r\n    local s, e = string.find(deviceName, \"%[.+%]\")\r\n    if s and e then\r\n        local pureName = string.gsub(string.sub(deviceName, 1, s-1), \"%s+$\", \"\")\r\n        local metaStr = string.sub(deviceName, s+1, e-1)\r\n\r\n        metaInfo.pureName = pureName\r\n \r\n        local attrs = splitStringToNumbers(metaStr, \"%.\")\r\n        if attrs[1] == \"1\" then\r\n            metaInfo.autoPower = true\r\n        else\r\n            metaInfo.autoPower = false\r\n        end\r\n\r\n        if attrs[2] and attrs[2] ~= \"-\" then \r\n            metaInfo.turnOffTimeout = math.ceil(attrs[2] * 60)\r\n        end\r\n\r\n        if attrs[3] and attrs[3] ~= \"-\" then \r\n            metaInfo.segmentId = tonumber(attrs[3])\r\n            metaInfo.rooms = {}\r\n\r\n            local segmentIdsStr = fibaro.getGlobalVariable(\"segment_\" .. metaInfo.segmentId)\r\n            if segmentIdsStr then\r\n                local roomIds = splitStringToNumbers(segmentIdsStr, \",\")\r\n                for i,roomIdStr in ipairs(roomIds) do\r\n                    metaInfo.rooms[i] = roomIdStr\r\n                end\r\n            end\r\n        end\r\n    else\r\n        metaInfo.name = deviceName\r\n    end\r\n\r\n    return metaInfo\r\nend\r\n\r\nfunction splitString(str, sep)\r\n  local fields = {}\r\n  str:gsub(\"([^\" .. sep ..\"]+)\",function(c) fields[#fields+1]=c:gsub(\"^%s*(.-)%s*$\", \"%1\") end)\r\n  return fields\r\nend\r\n\r\n\r\nfunction splitStringToNumbers(str, sep)\r\n  local fields = {}\r\n  str:gsub(\"([^\" .. sep ..\"]+)\",function(c) fields[#fields+1]=c end)\r\n  return fields\r\nend\r\n\r\nfunction table_contains_value(tab, val)\r\n    if not tab then\r\n        return false\r\n    end\r\n    \r\n    for index, value in ipairs(tab) do\r\n        if value == val then\r\n            return true\r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction createFibaroEventPayload(device, propertyName, newValue) \r\n    -- THIS IS FIBARO EVENT FORMAT => DO NOT CHANGE VARIABLE NAMES\r\n    local payload = {\r\n        data = {\r\n            id = device.id,\r\n            property = propertyName,\r\n            newValue = newValue\r\n        },\r\n        type = \"DevicePropertyUpdatedEvent\",\r\n        created = os.time()\r\n    }\r\n\r\n    return payload\r\nend\r\n\r\nfunction isEmptyString(s)\r\n  return s == nil or s == \"\"\r\nend\r\n\r\nfunction base64Encode(data)\r\n    local b ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\n    return ((data:gsub('.', function(x) \r\n        local r,b='',x:byte()\r\n        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\r\n        return r;\r\n    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\r\n        if (#x < 6) then return '' end\r\n        local c=0\r\n        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\r\n        return b:sub(c+1,c+1)\r\n    end)..({ '', '==', '=' })[#data%3+1])\r\nend\r\n\r\nfunction base64Decode(data)\r\n    local b ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\n    data = string.gsub(data, '[^'..b..'=]', '')\r\n    return (data:gsub('.', function(x)\r\n        if (x == '=') then return '' end\r\n        local r,f='',(b:find(x)-1)\r\n        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end\r\n        return r;\r\n    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)\r\n        if (#x ~= 8) then return '' end\r\n        local c=0\r\n        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end\r\n        return string.char(c)\r\n    end))\r\nend\r\n\r\nfunction decodeBase64Auth(encoded)\r\n    local decoded = base64Decode(encoded)\r\n    \r\n    local i = string.find(decoded, \":\")\r\n\r\n    if i then\r\n        return string.sub(decoded, 0, i-1), string.sub(decoded, i+1, string.len(decoded))\r\n    else\r\n        return nil\r\n    end\r\nend\r\n\r\nfunction shallowInsertTo(from, to)\r\n    local orig_type = type(from)\r\n    if orig_type == 'table' then\r\n        for orig_key, orig_value in pairs(from) do\r\n            table.insert(to, orig_value)\r\n        end\r\n    else -- number, string, boolean, etc\r\n        copy = from\r\n    end\r\nend\r\n\r\nfunction shallowCopyTo(from, to)\r\n    local orig_type = type(from)\r\n    if orig_type == 'table' then\r\n        for orig_key, orig_value in pairs(from) do\r\n            to[orig_key] = orig_value\r\n        end\r\n    else -- number, string, boolean, etc\r\n        copy = from\r\n    end\r\nend\r\n\r\n\r\nfunction clone(orig)\r\n    local orig_type = type(orig)\r\n    local copy\r\n    if orig_type == 'table' then\r\n        copy = {}\r\n        for orig_key, orig_value in next, orig, nil do\r\n            copy[clone(orig_key)] = clone(orig_value)\r\n        end\r\n        --setmetatable(copy, clone(getmetatable(orig)))\r\n    else -- number, string, boolean, etc\r\n        copy = orig\r\n    end\r\n    return copy\r\nend\r\n\r\nfunction inheritFrom(orig)\r\n    return clone(orig)\r\nend\r\n\r\nfunction isNumber(value)\r\n    if type(value) == \"number\" then return true end\r\n\r\n    if value == tostring(tonumber(value)) then\r\n        return true\r\n    else\r\n        return false\r\n    end\r\nend\r\n\r\nfunction round(number, dec)\r\n    local k = 10^dec\r\n\r\n    local result = math.floor(number * k + 0.5) / k\r\n\r\n    local resultWithoutTrailingZero = math.floor(result)\r\n    if (resultWithoutTrailingZero ~= result) then\r\n        return result\r\n    else\r\n        return resultWithoutTrailingZero\r\n    end\r\n\r\n    return result\r\nend\r\n\r\nfunction identifyLocalIpAddressForHc3()\r\n    local networkInterfaces = api.get(\"/proxy?url=http://127.0.0.1:11112/api/settings/network\")\r\n    for i, j in pairs(networkInterfaces.networkConfig) do\r\n        if (j.enabled) then\r\n            return j.ipConfig.ip\r\n        end\r\n    end\r\n\r\n    print(\"[WARNING] Cannot identify HC3 local ip address\")\r\n    \r\n    return \"unknown\"\r\nend\r\n\r\ntable.indexOf = function( t, object )\r\n\tlocal result\r\n\r\n    for i=1,#t do\r\n        if object == t[i] then\r\n            result = i\r\n            break\r\n        end\r\n    end\r\n\r\n\treturn result\r\nend\r\n"},{"name":"mqtt_convention_api","isMain":false,"isOpen":true,"content":"MqttConventionPrototype = {\r\n    type = \"'type' needs to be overriden\", \r\n    mqtt = \"MQTT connection must be established first\"\r\n}\r\n \r\nfunction MqttConventionPrototype:getLastWillMessage() \r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onConnected()\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDeviceNodeCreated(deviceNode)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDeviceNodeRemoved(deviceNode)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onPropertyUpdated(deviceNode, event)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onCommand(event)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDisconnected()\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\n-----------------------------------\r\n-- HOME ASSISTANT \r\n-----------------------------------\r\nMqttConventionHomeAssistant = inheritFrom(MqttConventionPrototype) \r\nMqttConventionHomeAssistant.type = \"Home Assistant\"\r\nMqttConventionHomeAssistant.rootTopic = \"homeassistant/\"\r\n\r\n-- TOPICS \r\nfunction MqttConventionHomeAssistant:getDeviceTopic(haEntity)\r\n    -- *** rework to use own TOPICS and remove type usage\r\n    return self.rootTopic .. tostring(haEntity.type) .. \"/\" .. haEntity.id .. \"/\"\r\nend\r\nfunction MqttConventionHomeAssistant:getGenericEventTopic(haEntity, eventType, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(haEntity) .. \"events/\" .. eventType .. \"/\" .. propertyName \r\n    else\r\n        return self:getDeviceTopic(haEntity) .. \"events/\" .. eventType\r\n    end\r\nend\r\nfunction MqttConventionHomeAssistant:getterTopic(haEntity, propertyName)\r\n    -- *** REWORK TO USE ALL LINKED DEVICE PROPERTIES?\r\n    if (haEntity.linkedEntity and propertyName == \"value\") then\r\n        local result = self:getGenericEventTopic(haEntity.linkedEntity, \"DevicePropertyUpdatedEvent\", haEntity.linkedProperty)\r\n        return result\r\n    elseif (haEntity.linkedEntity and propertyName == \"dead\") then\r\n        local result = self:getGenericEventTopic(haEntity.linkedEntity, \"DevicePropertyUpdatedEvent\", \"dead\")\r\n        return result\r\n    else\r\n        return self:getGenericEventTopic(haEntity, \"DevicePropertyUpdatedEvent\", propertyName)\r\n    end\r\nend\r\nfunction MqttConventionHomeAssistant:getGenericCommandTopic(haEntity, command, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(haEntity) .. command ..  \"/\" .. propertyName\r\n    else\r\n        return self:getDeviceTopic(haEntity) .. command\r\n    end\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:setterTopic(haEntity, propertyName)\r\n    return self:getGenericCommandTopic(haEntity, \"set\", propertyName)\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:getLastWillAvailabilityTopic()\r\n    return self.rootTopic .. \"hc3-dead\"\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:getLastWillMessage()\r\n    return {\r\n        topic = self:getLastWillAvailabilityTopic(),\r\n        payload = \"true\",\r\n        {\r\n            retain = true\r\n        }\r\n    }    \r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onConnected()\r\n    self.mqtt:publish(self.rootTopic .. \"hc3-dead\", \"false\", {retain = true})\r\n    self.mqtt:subscribe(self.rootTopic .. \"+/+/set/+\")\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDisconnected()\r\n    self.mqtt:publish(self.rootTopic .. \"hc3-dead\", \"true\", {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDeviceNodeCreated(deviceNode)\r\n    local haEntity = deviceNode.identifiedHaEntity\r\n    --print(\"PUBLISH DEVICE: \" .. deviceNode.fibaroDevice.id .. \" \" .. deviceNode.fibaroDevice.name)\r\n    if (haEntity.type == RemoteControllerKey.type) then\r\n        -- Home Assistant pretty unique spec for \"device_automation/trigger\" devices\r\n        -- so better use another factory type for MQTT Discovery Message\r\n        MqttConventionHomeAssistant:onRemoteControllerKeyCreated(deviceNode, self.mqtt)\r\n        return\r\n    end\r\n\r\n    ------------------------------------------\r\n    --- AVAILABILITY\r\n    ------------------------------------------\r\n    local msg = {\r\n        unique_id = tostring(haEntity.id),\r\n        object_id = tostring(haEntity.id),\r\n        name = haEntity.name .. \" (\" .. haEntity.roomName .. \")\",\r\n\r\n        availability_mode = \"all\",\r\n        availability = {\r\n            {\r\n                topic = self:getLastWillAvailabilityTopic(),\r\n                payload_available = \"false\",\r\n                payload_not_available = \"true\"\r\n            }\r\n            ,\r\n            {\r\n                topic = self:getterTopic(haEntity, \"dead\"),\r\n                payload_available = \"false\",\r\n                payload_not_available = \"true\" \r\n            }\r\n        },\r\n\r\n        json_attributes_topic = self:getDeviceTopic(haEntity) .. \"config_json_attributes\" \r\n    }\r\n\r\n    ------------------------------------------\r\n    --- PARENT DEVICE INFO\r\n    ------------------------------------------\r\n    msg.device = deviceNode.identifiedHaDevice\r\n\r\n    ------------------------------------------\r\n    --- USE \"TRUE\"/\"FALSE\" VALUE PAYLOAD, instead of \"ON\"/\"OFF\"\r\n    ------------------------------------------\r\n    if (haEntity.supportsRead) then\r\n        if (haEntity.supportsBinary and haEntity.type ~= \"cover\") then \r\n            msg.payload_on = \"true\"\r\n            msg.payload_off = \"false\"\r\n        end\r\n    end\r\n    \r\n    ------------------------------------------\r\n    ---- READ\r\n    ------------------------------------------\r\n    -- Does device have binary state to share?\r\n    if (haEntity.supportsRead and haEntity.supportsBinary) then\r\n        msg.state_topic = self:getterTopic(haEntity, \"state\")\r\n        \r\n        if (haEntity.type == \"light\") then\r\n            msg.state_value_template = \"{{ value_json.value }}\"\r\n        else\r\n            -- wish Home Assistant spec was consistent for all device types and \"state_value_template\" was used for all the devices with \"state\" property\r\n            msg.value_template = \"{{ value_json.value }}\"\r\n        end\r\n    end\r\n    -- Does device have multilevel state to share?\r\n    if (haEntity.supportsRead and haEntity.supportsMultilevel) then\r\n        if (haEntity.type == \"light\") then\r\n            msg.brightness_state_topic = self:getterTopic(haEntity, \"value\")\r\n            msg.brightness_value_template = \"{{ value_json.value }}\"\r\n        elseif (haEntity.type == \"cover\") then\r\n            msg.position_topic = self:getterTopic(haEntity, \"value\")\r\n        elseif (haEntity.type == \"sensor\") then\r\n            msg.state_topic = self:getterTopic(haEntity, \"value\")\r\n            msg.value_template = \"{{ value_json.value }}\"\r\n        else\r\n            msg.value_template = \"{{ value_json.value }}\"\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- WRITE\r\n    ------------------------------------------\r\n    -- Does haEntity support binary write operations?\r\n    if (haEntity.supportsWrite and haEntity.supportsBinary) then\r\n        msg.command_topic = self:setterTopic(haEntity, \"state\")\r\n    end\r\n    -- Does haEntity support multilevel write operations?\r\n    if (haEntity.supportsWrite) and (haEntity.supportsMultilevel) then\r\n        if (haEntity.type == \"light\") then\r\n            msg.brightness_command_topic = self:setterTopic(haEntity, \"value\")\r\n            msg.brightness_scale = 99\r\n            msg.on_command_type = \"first\"\r\n        elseif (haEntity.type == \"cover\") then\r\n            msg.set_position_topic = self:setterTopic(haEntity, \"value\")\r\n            msg.position_template = \"{{ value_json.value }}\"\r\n            -- value_template is deprecated since Home Assistant Core 2021.6.\r\n            msg.value_template = nil\r\n            msg.position_open = 99\r\n            msg.position_closed = 0\r\n\r\n            msg.payload_open = \"open\"\r\n            msg.payload_close = \"close\"\r\n            msg.payload_stop = \"stop\"\r\n\r\n            msg.state_open = \"open\"\r\n            msg.state_closed = \"closed\"\r\n            msg.state_opening = \"opening\"\r\n            msg.state_closing = \"closing\"\r\n            msg.state_topic = self:setterTopic(haEntity, \"state\")\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- SENSOR SPECIFIC\r\n    ------------------------------------------\r\n    if (haEntity.type == \"binary_sensor\" or haEntity.type == \"sensor\") then\r\n        -- *** refactor, but keep device_class 'None' when default sensor is used by the QuickApp\r\n        if (PrototypeEntity.subtype ~= haEntity.subtype) then\r\n            msg.device_class = haEntity.subtype\r\n        end\r\n        -- *** refactor?\r\n        if (PrototypeEntity.bridgeUnitOfMeasurement ~= haEntity.bridgeUnitOfMeasurement) then\r\n            msg.unit_of_measurement = haEntity.bridgeUnitOfMeasurement\r\n        end\r\n\r\n        -- Energy meter requires extra properties\r\n        if (haEntity.subtype == \"energy\") then\r\n            msg.state_class = \"total_increasing\"\r\n        end\r\n\r\n        if (haEntity.subtype == RemoteController.subtype) then\r\n            -- Remote controller sensor is not natively supported by Home Assistant, thus need to replace \"remoteController\" subtype with \"None\" haEntity class\r\n            msg.device_class = nil\r\n            -- Add \"remote\" icon\r\n            msg.icon = \"mdi:remote\"\r\n        end\r\n\r\n        if (haEntity.type == RemoteController.type) and (haEntity.subtype == RemoteController.subtype) then\r\n            msg.expire_after = 10\r\n        end\r\n    end\r\n\r\n    ------------------------------------------ \r\n    ---- THERMOSTAT SPECIFIC\r\n    ------------------------------------------\r\n    if (haEntity.type == \"climate\") then\r\n        -- **** refactor\r\n        msg.modes = deviceNode.identifiedHaEntity.properties.supportedThermostatModes\r\n        --msg.modes = deviceNode.fibaroDevice.properties.supportedThermostatModes\r\n \r\n        msg.temperature_unit = deviceNode.fibaroDevice.properties.unit\r\n        msg.temp_step = deviceNode.fibaroDevice.properties.heatingThermostatSetpointStep[msg.temperature_unit]\r\n\r\n        -- MODE \r\n        msg.mode_state_topic = self:getterTopic(haEntity, \"thermostatMode\")\r\n        msg.mode_command_topic = self:setterTopic(haEntity, \"thermostatMode\")\r\n\r\n        -- MIX/MAX TEMPERATURE\r\n        msg.min_temp = deviceNode.fibaroDevice.properties.heatingThermostatSetpointCapabilitiesMin\r\n        msg.max_temp = deviceNode.fibaroDevice.properties.heatingThermostatSetpointCapabilitiesMax\r\n\r\n        -- TARGET TEMPERATURE\r\n        msg.temperature_state_topic = self:getterTopic(haEntity, \"heatingThermostatSetpoint\")\r\n        msg.temperature_command_topic = self:setterTopic(haEntity, \"heatingThermostatSetpoint\")\r\n        \r\n        -- CURRENT TEMPERATURE\r\n        local temperatureSensorEntity = haEntity:getTemperatureSensor()\r\n        if temperatureSensorEntity then \r\n            msg.current_temperature_topic = self:getterTopic(temperatureSensorEntity, \"value\")\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- RGBW\r\n    ------------------------------------------\r\n    if (haEntity.type == \"light\" and haEntity.subtype == \"rgbw\") then\r\n        msg.rgbw_state_topic = self:getterTopic(haEntity, \"color\")\r\n        msg.rgbw_value_template = \"{{ value_json.value.split(',')[:4] | join(',') }}\"\r\n        msg.rgbw_command_topic = self:setterTopic(haEntity, \"color\")\r\n    end\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(haEntity) .. \"config\", json.encode(msg), {retain = true})\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(haEntity) .. \"config_json_attributes\", json.encode(deviceNode.fibaroDevice), {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onRemoteControllerKeyCreated(deviceNode, mqtt)\r\n    local haEntity = deviceNode.identifiedHaEntity\r\n    \r\n    local keyId = deviceNode.fibaroDevice.keyId\r\n    local keyType = self:convertKeyAttributeToType(deviceNode.fibaroDevice.keyAttribute)\r\n    \r\n    local msg = {\r\n        automation_type = \"trigger\",\r\n\r\n        topic = self:getterTopic(haEntity, \"value\"),\r\n        value_template = \"{{ value_json.value }}\", \r\n\r\n        type = keyType, \r\n        subtype = \"button_\" .. keyId,\r\n        payload = keyId .. \"-\" .. keyType\r\n    }\r\n\r\n    ------------------------------------------\r\n    --- PARENT DEVICE INFO\r\n    ------------------------------------------\r\n    msg.device = deviceNode.identifiedHaDevice\r\n\r\n    mqtt:publish(self:getDeviceTopic(haEntity) .. \"config\", json.encode(msg), {retain = true})\r\nend\r\n\r\nlocal keyAttributeToTypeMap = {\r\n    [\"pressed\"] = \"button_short_press\",\r\n    [\"pressed2\"] = \"button_double_press\",\r\n    [\"pressed3\"] = \"button_triple_press\",\r\n    [\"helddown\"] = \"button_long_press\",\r\n    [\"released\"] = \"button_long_release\"\r\n}\r\nfunction MqttConventionHomeAssistant:convertKeyAttributeToType(keyAttribute)\r\n    local type = keyAttributeToTypeMap[keyAttribute]\r\n    if not type then\r\n        print(\"Unknown key attribute \\\"\" .. tostring(keyAttribute) .. \"\\\"\")\r\n        type = \"unknown-\" .. keyAttribute\r\n    end\r\n\r\n    return type\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDeviceNodeRemoved(deviceNode)\r\n    self.mqtt:publish(\r\n        self:getDeviceTopic(deviceNode.identifiedHaEntity) .. \"config\", \r\n        \"\",\r\n        {retain = true} \r\n    )\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onPropertyUpdated(deviceNode, event)\r\n    local propertyName = event.data.property\r\n\r\n    local value = event.data.newValue\r\n\r\n    local haEntity = deviceNode.identifiedHaEntity\r\n\r\n    -------------------------------------------\r\n    -- COVER SPECIFIC\r\n    -------------------------------------------\r\n    if haEntity.type == \"cover\" then \r\n        if propertyName == \"value\" then\r\n            -- Fibaro doesn't use \"state\" attribute for covers, so we'll trigger it on behalf of Fibaro based on \"value\" attribute\r\n            local state\r\n            if value < 20 then\r\n                state = \"closed\"\r\n            elseif value > 80 then\r\n                state = \"open\"\r\n            else\r\n                state = \"unknown\"\r\n            end\r\n\r\n            if state then\r\n                local payload = {\r\n                    id = haEntity.id,\r\n                    deviceName = haEntity.name,\r\n                    created = event.created,\r\n                    timestamp = os.date(),\r\n                    roomName = haEntity.roomName,\r\n                    value = state\r\n                }\r\n                formattedState = json.encode(payload)\r\n                --formattedState = state\r\n                -- *** DUPLICATE?\r\n                self.mqtt:publish(self:getterTopic(haEntity, \"state\"), formattedState, {retain = true})\r\n            end\r\n        elseif propertyName == \"state\" then\r\n            if (value == \"unknown\") then\r\n                -- drop event as Fibaro has \"Uknnown\" value constantly assigned to the \"state\" attribute \r\n                return\r\n            end\r\n        end\r\n    end\r\n\r\n    -------------------------------------------\r\n    -- REMOTE CONTROLLER (SENSOR) SPECIFIC\r\n    -------------------------------------------\r\n    if haEntity.type == RemoteController.type and haEntity.subtype == RemoteController.subtype and propertyName == \"value\" then\r\n        local keyValues = splitString(value, \",\")\r\n\r\n        local keyId = keyValues[1]\r\n        local keyAttribute = keyValues[2]\r\n        local keyType = self:convertKeyAttributeToType(keyAttribute)\r\n        \r\n        value = keyId .. \"-\" .. keyType\r\n    end\r\n    \r\n    value = string.lower(value)\r\n\r\n    local formattedPayload \r\n    if propertyName == \"dead\" then\r\n    -- *** CHECK/REFACTOR\r\n    --if ((propertyName == \"dead\") or (device.type == RemoteController.type and device.subtype == RemoteController.subtype)) then\r\n        formattedPayload = tostring(value)\r\n    else\r\n        local payload = {\r\n            id = haEntity.id,\r\n            deviceName = haEntity.name,\r\n            created = event.created,\r\n            timestamp = os.date(),\r\n            roomName = haEntity.roomName,\r\n            value = value\r\n        }\r\n        formattedPayload = json.encode(payload)\r\n    end\r\n\r\n    -- *** DUPLICATE?\r\n    self.mqtt:publish(self:getterTopic(haEntity, propertyName), formattedPayload, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onCommand(event)\r\n    if (string.find(event.topic, self.rootTopic) == 1) then\r\n        -- Home Assistant command detected\r\n        local topicElements = splitString(event.topic, \"/\")\r\n        local deviceId = tonumber(topicElements[3])\r\n        local propertyName = topicElements[5]\r\n\r\n        local device = deviceNodeById[deviceId].identifiedHaEntity\r\n\r\n        local value = event.payload\r\n\r\n        if (device.type == \"climate\") then\r\n            -- Fibaro HC3 uses first letter in upper case, and HA relies on lower case\r\n            -- *** rename to firstCharacter\r\n            local firstPart = string.upper(string.sub(value, 1, 1))\r\n            local secondPart = string.sub(value, 2, string.len(value))\r\n            value = firstPart .. secondPart\r\n        end\r\n\r\n        device:setProperty(propertyName, value)\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- HOMIE\r\n-----------------------------------\r\nMqttConventionHomie = inheritFrom(MqttConventionPrototype) \r\nMqttConventionHomie.type = \"Homie\"\r\nMqttConventionHomie.rootTopic = \"homie/\"\r\n\r\n-- TOPICS \r\nfunction MqttConventionHomie:getDeviceTopic(device)\r\n    return self.rootTopic .. device.id .. \"/\"\r\nend\r\nfunction MqttConventionHomie:getGenericEventTopic(device, eventType, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType .. \"/\" .. propertyName \r\n    else\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType\r\n    end\r\nend\r\nfunction MqttConventionHomie:getterTopic(device, propertyName)\r\n    return self:getGenericEventTopic(device, \"DevicePropertyUpdatedEvent\", propertyName)     \r\nend\r\nfunction MqttConventionHomie:getGenericCommandTopic(device, command, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. command ..  \"/\" .. propertyName\r\n    else\r\n        return self:getDeviceTopic(device) .. command\r\n    end\r\nend\r\n\r\nfunction MqttConventionHomie:getSetterTopic(device, propertyName)\r\n    return self:getGenericCommandTopic(device, \"set\", propertyName)\r\nend\r\n\r\nfunction MqttConventionHomie:getLastWillMessage() \r\n    return {\r\n        topic = self.rootTopic .. \"hc3-dead\",\r\n        payload = \"true\",\r\n        lastWill = true\r\n    }    \r\nend\r\n\r\nfunction MqttConventionHomie:onConnected()\r\n    self.mqtt:subscribe(self.rootTopic .. \"+/+/+/set\")\r\nend\r\n\r\nfunction MqttConventionHomie:onDisconnected()\r\nend\r\n\r\nfunction MqttConventionHomie:onDeviceNodeCreated(deviceNode)\r\n    local device = deviceNode.identifiedHaEntity\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$homie\", \"2.1.0\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$name\", device.name .. \" (\" .. deviceNode.fibaroDevice.roomName .. \")\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$implementation\", \"Fibaro HC3 to MQTT bridge\", {retain = true})\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$nodes\", \"node\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$name\", device.name, {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$type\", \"\", {retain = true})\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$extensions\", \"\", {retain = true})\r\n\r\n    local properties = { }\r\n\r\n    if (device.supportsRead) then\r\n        local propertyName = device.type\r\n        -- *** get rid of this check\r\n        --if (PrototypeEntity.subtype ~= device.subtype) then\r\n            propertyName = propertyName .. \" - \" .. tostring(device.subtype)\r\n        --end\r\n\r\n        if (device.supportsBinary) then\r\n            properties[\"state\"] = {\r\n                name = device.type,\r\n                datatype = \"boolean\",\r\n                settable = device.supportsWrite, \r\n                retained = true,\r\n            }\r\n        end\r\n\r\n        if (device.supportsMultilevel) then\r\n            properties[\"value\"] = {\r\n                name = device.type,\r\n                datatype = \"integer\",\r\n                settable = device.supportsWrite,\r\n                retained = true,\r\n                unit = device.bridgeUnitOfMeasurement\r\n            }\r\n        end\r\n    end\r\n\r\n    local propertiesStr = \"\"\r\n    local firstParameter = true\r\n    for i, j in pairs(properties) do\r\n        if (not firstParameter) then\r\n            propertiesStr = propertiesStr .. \",\"\r\n        end\r\n        propertiesStr = propertiesStr .. i\r\n        firstParameter = false\r\n    end\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$properties\", propertiesStr, {retain = true})\r\n\r\n    for i, j in pairs(properties) do\r\n        local propertyTopic = self:getDeviceTopic(device) .. \"node/\" .. i .. \"/$\"\r\n        for m, n in pairs(j) do\r\n            self.mqtt:publish(propertyTopic .. m, tostring(n), {retain = true})\r\n        end\r\n    end\r\n\r\n    local homieState\r\n    if (deviceNode.fibaroDevice.dead) then\r\n        homieState = \"lost\"\r\n    else\r\n        homieState = \"ready\"\r\n    end\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$state\", homieState, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomie:onDeviceNodeRemoved(deviceNode)\r\nend\r\n\r\nfunction MqttConventionHomie:onPropertyUpdated(deviceNode, event)\r\n    local propertyName = event.data.property\r\n\r\n    local value = event.data.newValue\r\n\r\n    -- *** rename device to haEntity\r\n    local device = deviceNode.identifiedHaEntity\r\n\r\n    value = string.lower(value)\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/\" .. propertyName, value, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomie:onCommand(event)\r\n    if (string.find(event.topic, self.rootTopic) == 1) then\r\n        local topicElements = splitString(event.topic, \"/\")\r\n        local deviceId = tonumber(topicElements[2])\r\n        local device = deviceNodeById[deviceId].identifiedHaEntity\r\n\r\n        local propertyName = topicElements[4]\r\n        local value = event.payload\r\n\r\n        device:setProperty(propertyName, value)\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- FOR EXTENDED DEBUG PURPOSES\r\n-----------------------------------\r\n\r\nMqttConventionDebug = inheritFrom(MqttConventionPrototype) \r\nMqttConventionDebug.type = \"Debug\"\r\nfunction MqttConventionDebug:getLastWillMessage() \r\nend\r\nfunction MqttConventionDebug:onDeviceNodeCreated(deviceNode)\r\nend\r\nfunction MqttConventionDebug:onDeviceNodeRemoved(deviceNode)\r\nend\r\nfunction MqttConventionDebug:onPropertyUpdated(deviceNode, event)\r\nend\r\nfunction MqttConventionDebug:onConnected()\r\nend\r\nfunction MqttConventionDebug:onCommand(event)\r\nend\r\nfunction MqttConventionDebug:onDisconnected()\r\nend\r\n\r\n-----------------------------------\r\n-- MQTT CONVENTION MAPPINGS\r\n-----------------------------------\r\n\r\nmqttConventionMappings = {\r\n    [\"home-assistant\"] = MqttConventionHomeAssistant,\r\n    [\"homie\"] = MqttConventionHomie,\r\n    [\"debug\"] = MqttConventionDebug\r\n} \r\n\r\n\r\nlocalIpAddress = identifyLocalIpAddressForHc3()\r\n"},{"name":"device_api","isMain":false,"isOpen":true,"content":"----------------------------------- \r\n-- CACHE FOR QUICKAPP PERFORMANCE BOOST \r\n-----------------------------------\r\n-- **** ADD VIRTUAL ROOT NODE AT LEVEL 0\r\ndeviceHierarchy = { }\r\ndeviceNodeById = { }\r\ndeviceFilter = { }\r\n\r\nallFibaroDevicesAmount = 0\r\nfilteredFibaroDevicesAmount = 0\r\nidentifiedHaEntitiesAmount = 0\r\n\r\n----------------------------------- \r\n-- PROTOTYPE OBJECT \r\n-----------------------------------\r\nPrototypeEntity = {\r\n    -- mandatory\r\n    type = \"'type' needs to be initialized\",\r\n    supportsBinary = \"'supportsBinary' needs to be initialized\",\r\n    binaryProperty = \"value\",\r\n    supportsMultilevel = \"'supportsMultilevel' needs to be initialized\",\r\n    supportsRead = \"'supportsRead' needs to be initialized\",\r\n    supportsWrite = \"'supportsWrite' needs to be initialized\",\r\n\r\n    -- optional\r\n    subtype = \"default\",\r\n    modes = \"'modes' needs to be initialized to an array of modes, e.g. 'heat', 'cool'\",\r\n    icon = \"&#128230;\",\r\n    properties = { },\r\n    customPropertySetters = nil -- could be optionally set by a child class\r\n} \r\n\r\nfunction PrototypeEntity:new(deviceNode)\r\n    local status, haEntity = pcall(clone, self)\r\n\r\n    local fibaroDevice = deviceNode.fibaroDevice\r\n    haEntity.sourceDeviceNode = deviceNode\r\n\r\n    haEntity.id = fibaroDevice.id\r\n    haEntity.name = fibaroDevice.name\r\n    haEntity.roomName = fibaroDevice.roomName\r\n\r\n    local linkedFibaroDevice = fibaroDevice.linkedDevice\r\n    if linkedFibaroDevice then\r\n        haEntity.linkedEntity = deviceNodeById[linkedFibaroDevice.id].identifiedHaEntity\r\n        haEntity.linkedProperty = fibaroDevice.linkedProperty\r\n    end\r\n\r\n    haEntity:init(fibaroDevice)\r\n\r\n    return haEntity\r\nend\r\n\r\nfunction PrototypeEntity:init(fibaroDevice)\r\n    -- \"init\" function could be optionally overriden by subclasses implementation\r\nend \r\n\r\nfunction PrototypeEntity:setProperty(propertyName, value)\r\n    if isEmptyString(value) then\r\n        return\r\n    end\r\n\r\n    local customPropertySetter\r\n    if (self.customPropertySetters ~= nil) then\r\n        customPropertySetter = self.customPropertySetters[propertyName]\r\n    end\r\n\r\n    if (customPropertySetter == nil) then\r\n        -- DEFAULT PROPERTY SETTER\r\n        if (propertyName == \"state\") then\r\n            if (value == \"true\") then\r\n                --print(\"Turn ON for device #\" .. self.id)\r\n                fibaro.call(self.id, \"turnOn\")\r\n            elseif (value == \"false\") then\r\n                --print(\"Turn OFF for device #\" .. self.id)\r\n                fibaro.call(self.id, \"turnOff\")\r\n            else\r\n                print(\"Unexpected value: \" .. json.encode(event))\r\n            end\r\n        else\r\n            -- *** rename to firstCharacter\r\n            local firstPart = string.upper(string.sub(propertyName, 1, 1))\r\n            local secondPart = string.sub(propertyName, 2, string.len(propertyName))\r\n\r\n            local functionName = \"set\" .. firstPart .. secondPart\r\n            print(\"FUNCTION CALL: \\\"\" .. functionName .. \"\\\", with VALUE \\\"\" .. value .. \"\\\" for device #\" .. self.id)\r\n\r\n            if (propertyName == \"color\") then\r\n                local newRgbw = splitStringToNumbers(value, \",\")\r\n                fibaro.call(self.id, functionName, newRgbw[1], newRgbw[2], newRgbw[3], newRgbw[4])\r\n            else\r\n                fibaro.call(self.id, functionName, value)\r\n            end\r\n        end\r\n    else\r\n        -- CUSTOM PROPERTY SETTER\r\n        print(\"[CUSTOM PROPERTY] SET \\\"\" .. propertyName .. \"\\\" to \\\"\" .. value .. \"\\\" for device #\" .. self.id)\r\n        customPropertySetter(propertyName, value)\r\n    end\r\nend\r\n\r\nfunction PrototypeEntity:fibaroDeviceHasType(type)\r\n    return fibaroDeviceHasType(self.sourceDeviceNode.fibaroDevice, type)\r\nend\r\n\r\nfunction PrototypeEntity:fibaroDeviceHasNoType(type)\r\n    return not fibaroDeviceHasType(self.sourceDeviceNode.fibaroDevice, type)\r\nend\r\n\r\nfunction PrototypeEntity:fibaroDeviceHasInterface(interface)\r\n    return table_contains_value(self.sourceDeviceNode.fibaroDevice, interface)\r\nend\r\n\r\nfunction PrototypeEntity:fibaroDeviceHasNoInterface(interface)\r\n    return not fibaroDeviceHasInterface(self.sourceDeviceNode.fibaroDevice, interface)\r\nend\r\n\r\n-----------------------------------\r\n-- BINARY SWITCH\r\n-----------------------------------\r\nSwitch = inheritFrom(PrototypeEntity)\r\nSwitch.type = \"switch\"\r\nSwitch.subtype = \"binary\"\r\nSwitch.supportsBinary = true\r\nSwitch.supportsMultilevel = false\r\nSwitch.supportsRead = true\r\nSwitch.supportsWrite = true\r\nSwitch.icon = \"&#128268;\" -- ðŸ”Œ\r\n\r\nfunction Switch.isSupported(fibaroDevice)\r\n    if fibaroDeviceHasType(fibaroDevice, \"com.fibaro.binarySwitch\") and fibaroDeviceHasNoInterface(fibaroDevice, \"light\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- BINARY LIGHT\r\n-----------------------------------\r\nLight = inheritFrom(PrototypeEntity)\r\nLight.type = \"light\"\r\nLight.subtype = \"binary\"\r\nLight.supportsBinary = true\r\nLight.supportsMultilevel = false\r\nLight.supportsRead = true\r\nLight.supportsWrite = true\r\nLight.icon = \"&#128161;\" -- ðŸ’¡\r\n\r\nfunction Light.isSupported(fibaroDevice)\r\n    if fibaroDeviceHasType(fibaroDevice, \"com.fibaro.binarySwitch\") and fibaroDeviceHasInterface(fibaroDevice, \"light\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL LIGHT (DIMMERS)\r\n-----------------------------------\r\nDimmer = inheritFrom(PrototypeEntity)\r\nDimmer.type = \"light\"\r\nDimmer.subtype = \"dimmer\"\r\nDimmer.supportsBinary = true\r\nDimmer.supportsMultilevel = true\r\nDimmer.supportsRead = true\r\nDimmer.supportsWrite = true\r\nDimmer.icon = \"&#128161;\"\r\n\r\nfunction Dimmer.isSupported(fibaroDevice)\r\n    if fibaroDeviceHasType(fibaroDevice, \"com.fibaro.multilevelSwitch\") and fibaroDeviceHasInterface(fibaroDevice, \"light\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL LIGHT (RGBW)\r\n-----------------------------------\r\nRgbw = inheritFrom(PrototypeEntity)\r\nRgbw.type = \"light\"\r\nRgbw.subtype = \"rgbw\" \r\nRgbw.supportsBinary = true\r\nRgbw.supportsMultilevel = true\r\nRgbw.supportsRead = true\r\nRgbw.supportsWrite = true\r\nRgbw.icon = \"&#127752;\" -- ðŸŒˆ\r\n\r\nfunction Rgbw.isSupported(fibaroDevice)\r\n    if fibaroDeviceHasType(fibaroDevice, \"com.fibaro.colorController\") and fibaroDeviceHasInterface(fibaroDevice, \"light\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- BINARY SENSOR (DOOR, MOTION, WATER LEAK, FIRE, SMORE SENSORSMULTILEVEL FOR TEMPERATURE, ETC)\r\n-----------------------------------\r\nBinarySensor = inheritFrom(PrototypeEntity)\r\nBinarySensor.type = \"binary_sensor\"\r\nBinarySensor.supportsBinary = true\r\nBinarySensor.supportsMultilevel = false\r\nBinarySensor.supportsRead = true \r\nBinarySensor.supportsWrite = false\r\nBinarySensor.icon = \"&#128065;&#65039;\" -- ðŸ‘ï¸\r\n\r\nfunction BinarySensor.isSupported(fibaroDevice)\r\n    if (string.find(fibaroDevice.baseType, \"Sensor\") or string.find(fibaroDevice.baseType, \"sensor\") or string.find(fibaroDevice.baseType, \"Detector\") or string.find(fibaroDevice.baseType, \"detector\")) then\r\n        --if (fibaroDevice.baseType ~= \"com.fibaro.multilevelSensor\") and (fibaroDevice.type ~= \"com.fibaro.multilevelSensor\") then\r\n        if fibaroDeviceHasNoType(fibaroDevice, \"com.fibaro.multilevelSensor\") then\r\n            return true \r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction BinarySensor:init(fibaroDevice)\r\n    -- ToDo: refactor with mappings\r\n    if self:fibaroDeviceHasType(\"com.fibaro.motionSensor\") then\r\n        self.subtype = \"motion\"\r\n    elseif self:fibaroDeviceHasType(\"com.fibaro.floodSensor\") then\r\n        self.subtype = \"moisture\" \r\n        self.icon = \"&#128167;\" -- ðŸ’§\r\n    elseif self:fibaroDeviceHasType(\"com.fibaro.doorWindowSensor\") then\r\n        if self:fibaroDeviceHasType(\"com.fibaro.doorSensor\") then\r\n            self.subtype = \"door\"\r\n            self.icon = \"&#128682;\" -- ðŸšª\r\n        elseif self:fibaroDeviceHasType(\"com.fibaro.windowSensor\") then\r\n            self.subtype = \"window\"\r\n            self.icon = \"&#129003;\" -- ðŸŸ«\r\n        else\r\n            print(\"[BinarySensor.init] Uknown doow/window sensor \" .. self.id .. \" \" .. self.name)\r\n        end\r\n    elseif self:fibaroDeviceHasType(\"com.fibaro.fireDetector\") or self:fibaroDeviceHasType(\"com.fibaro.fireSensor\") then\r\n        self.subtype = \"heat\"\r\n        self.icon = \"&#128293;\" -- ðŸ”¥\r\n    elseif self:fibaroDeviceHasType(\"com.fibaro.coDetector\") then\r\n        self.subtype = \"carbon_monoxide\"\r\n        self.icon = \"&#128168;\" -- ðŸ’¨\r\n    elseif self:fibaroDeviceHasType(\"com.fibaro.smokeSensor\") then\r\n        self.subtype = \"smoke\"\r\n        self.icon = \"&#128684;\" -- ðŸš¬\r\n    elseif self:fibaroDeviceHasType(\"com.fibaro.gasDetector\") then\r\n        self.subtype = \"gas\" \r\n        self.icon = \"&#128168;\" -- ðŸ’¨\r\n    elseif self:fibaroDeviceHasType(\"com.fibaro.lifeDangerSensor\") then\r\n        self.subtype = \"safety\"\r\n    else\r\n        self.subtype = nil\r\n        print(\"[BinarySensor.init] No sensor specialization for #\" .. tostring(self.id) .. \" \\\"\" .. tostring(self.name) .. \"\\\" that has type \" .. fibaroDevice.baseType .. \"-\" .. fibaroDevice.type .. \", thus using default sensor class\")\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL SENSOR (TEMPERATURE, HUMIDITY, VOLTAGE, ETC) \r\n-----------------------------------\r\nMultilevelSensor = inheritFrom(PrototypeEntity)\r\nMultilevelSensor.type = \"sensor\"\r\nMultilevelSensor.supportsBinary = false\r\nMultilevelSensor.supportsMultilevel = true\r\nMultilevelSensor.bridgeUnitOfMeasurement = \"'unit of measurement' needs to be initialized\"\r\nMultilevelSensor.supportsRead = true\r\nMultilevelSensor.supportsWrite = false\r\nMultilevelSensor.icon = \"&#128065;&#65039;\" -- ðŸ‘ï¸\r\n\r\nfunction MultilevelSensor.isSupported(fibaroDevice)\r\n    if (string.find(fibaroDevice.baseType, \"Sensor\") or string.find(fibaroDevice.baseType, \"sensor\") or string.find(fibaroDevice.baseType, \"Detector\") or string.find(fibaroDevice.baseType, \"detector\")) then\r\n        if fibaroDeviceHasType(fibaroDevice, \"com.fibaro.multilevelSensor\") then\r\n            return true \r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction MultilevelSensor:init(fibaroDevice)\r\n    -- initialize unit of measurement\r\n    self.bridgeUnitOfMeasurement = fibaroDevice.properties.unit\r\n\r\n    -- initialize subtype \r\n    -- ToDo *** refactor with mappings?\r\n    if self:fibaroDeviceHasType(\"com.fibaro.temperatureSensor\") then\r\n        self.subtype = \"temperature\"\r\n        self.bridgeUnitOfMeasurement = \"Â°\" .. fibaroDevice.properties.unit\r\n        self.icon = \"&#127777;&#65039;\" -- ðŸŒ¡ï¸\r\n    elseif self:fibaroDeviceHasType(\"com.fibaro.lightSensor\") then\r\n        self.subtype = \"illuminance\"\r\n    elseif self:fibaroDeviceHasType(\"com.fibaro.humiditySensor\") then \r\n        self.subtype = \"humidity\"\r\n    elseif self:fibaroDeviceHasType(\"com.fibaro.energySensor\") then \r\n        self.subtype = \"energy\"\r\n        self.icon = \"&#9889;\" -- âš¡\r\n    elseif self:fibaroDeviceHasType(\"com.fibaro.powerSensor\") then \r\n        self.subtype = \"power\"\r\n        self.icon = \"&#9889;\" -- âš¡\r\n    elseif self:fibaroDeviceHasType(\"com.fibaro.batteryLevelSensor\") then \r\n        self.subtype = \"battery\"\r\n        self.icon = \"&#128267;\" -- ðŸ”‹\r\n    elseif (self.subtype == RemoteController.subtype) then \r\n        -- *** REFACTOR\r\n        -- do nothing / the purpose for this logical condition is to make sure RemoteController doesn't fall into \"Unknown multilevel sensor\" category\r\n    elseif (fibaroDevice.properties.unit == \"V\") then\r\n        self.subtype = \"voltage\"\r\n        self.icon = \"&#9889;\" -- âš¡\r\n    elseif (fibaroDevice.properties.unit == \"A\") then\r\n        self.subtype = \"current\"\r\n        self.icon = \"&#9889;\" -- âš¡\r\n    elseif (fibaroDevice.properties.unit == \"Hz\") then\r\n        self.subtype = \"frequency\"\r\n    elseif (fibaroDevice.properties.unit == \"W\" or fibaroDevice.properties.unit == \"kW\" or fibaroDevice.properties.unit == \"kVA\") then\r\n        self.subtype = \"power\"\r\n        self.icon = \"&#9889;\" -- âš¡\r\n    else\r\n        print(\"[MultilevelSensor.init] No sensor specializationfor #\" .. tostring(self.id) .. \" \\\"\" .. tostring(self.name) .. \"\\\" that has type \" .. fibaroDevice.baseType .. \"-\" .. fibaroDevice.type .. \" and measured in '\" .. tostring(fibaroDevice.properties.unit) .. \"' unit, thus using default sensor class\")\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL SWITCH (COVER)\r\n-----------------------------------\r\nCover = inheritFrom(PrototypeEntity)\r\nCover.type = \"cover\"\r\nCover.supportsBinary = true\r\nCover.supportsMultilevel = true\r\nCover.supportsRead = true\r\nCover.supportsWrite = true\r\n\r\nfunction Cover.isSupported(fibaroDevice)\r\n    if (fibaroDevice.baseType == \"com.fibaro.baseShutter\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\nfunction Cover:init(fibaroDevice) \r\n    self.customPropertySetters = { }\r\n    self.customPropertySetters[\"state\"] = function (propertyName, value) \r\n        if (value == \"open\") then\r\n            fibaro.call(self.id, \"setValue\", 99)\r\n        elseif (value == \"close\") then\r\n            fibaro.call(self.id, \"setValue\", 0)\r\n        elseif (value == \"stop\") then\r\n            fibaro.call(self.id, \"stop\")\r\n        else\r\n            print(\"Unsupported state\")\r\n        end\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- THERMOSTAT (MULTILEVEL SWITCH)\r\n-----------------------------------\r\nThermostat = inheritFrom(PrototypeEntity)\r\nThermostat.type = \"climate\"\r\nThermostat.supportsBinary = false\r\nThermostat.supportsMultilevel = true\r\nThermostat.supportsRead = true\r\nThermostat.supportsWrite = true \r\nThermostat.icon = \"&#127965;&#65039;\" -- ðŸï¸\r\n\r\nfunction Thermostat.isSupported(fibaroDevice)\r\n    if fibaroDevice.baseType == \"com.fibaro.hvacSystem\" or fibaroDevice.type == \"com.fibaro.hvacSystem\" then \r\n        return true \r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\nfunction Thermostat:init(fibaroDevice) \r\n    local fibaroDeviceProperties = self.sourceDeviceNode.fibaroDevice.properties\r\n    \r\n    self.properties.supportedThermostatModes = { }\r\n    for i, mode in ipairs(fibaroDeviceProperties.supportedThermostatModes) do\r\n        self.properties.supportedThermostatModes[i] = string.lower(mode)\r\n    end\r\nend\r\n\r\nfunction Thermostat:setMode(mode)\r\n    fibaro.call(self.id, \"setThermostatMode\", mode)\r\nend\r\n\r\nfunction Thermostat:setHeatingThermostatSetpoint(targetTemperature)\r\n    fibaro.call(self.id, \"setHeatingThermostatSetpoint\", targetTemperature)\r\nend\r\n\r\nfunction Thermostat:getTemperatureSensor()\r\n    local sourceDeviceNode = self.sourceDeviceNode\r\n    local parentNode = sourceDeviceNode.parentNode\r\n\r\n    local relatedNodeList = {}\r\n    if (parentNode) then\r\n        shallowInsertTo(parentNode.childNodeList, relatedNodeList)    \r\n    end\r\n    shallowInsertTo(sourceDeviceNode.childNodeList, relatedNodeList)\r\n\r\n    for _, siblingNode in ipairs(relatedNodeList) do\r\n        if (siblingNode.included and siblingNode.identifiedHaEntity and siblingNode.identifiedHaEntity.type == \"sensor\" and siblingNode.identifiedHaEntity.subtype == \"temperature\") then\r\n            return siblingNode.identifiedHaEntity\r\n        end\r\n    end\r\n\r\n    return nil\r\nend\r\n\r\n-----------------------------------\r\n-- REMOTE CONTROLLER\r\n-----------------------------------\r\nRemoteController = inheritFrom(MultilevelSensor)\r\nRemoteController.subtype = \"remoteController\"\r\n\r\nfunction RemoteController.isSupported(fibaroDevice)\r\n    if ((fibaroDevice.baseType == \"com.fibaro.remoteController\") or ( fibaroDevice.baseType == \"com.fibaro.remoteSceneController\") or ( fibaroDevice.type == \"com.fibaro.remoteController\") or (fibaroDevice.type == \"com.fibaro.remoteSceneController\"))      then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n------------------------------------\r\n-- REMOTE CONTROLLER - BUTTON ACTION\r\n------------------------------------\r\nRemoteControllerKey = inheritFrom(PrototypeEntity)\r\nRemoteControllerKey.type = \"device_automation\"\r\nRemoteControllerKey.subtype = \"trigger\"\r\nRemoteControllerKey.supportsBinary = true\r\nRemoteControllerKey.supportsMultilevel = false\r\nRemoteControllerKey.supportsRead = true\r\nRemoteControllerKey.supportsWrite = false\r\nRemoteControllerKey.icon = \"&#9654;&#65039;\" -- â–¶ï¸\r\n\r\nfunction RemoteControllerKey.isSupported(fibaroDevice)\r\n    if (fibaroDevice.baseType == \"com.alexander_vitishchenko.remoteKey\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\nfunction RemoteControllerKey.init(fibaroDevice)\r\n    -- not needed for now\r\nend\r\n\r\n\r\n-----------------------------------\r\n-- HELPER FUNCTIONS - OVERRIDE \"WRONG\" DEVICE TYPES FROM FIBARO DEVICE API\r\n-----------------------------------\r\n\r\nlocal fibaroBaseTypeOverride = {\r\n    [\"com.fibaro.FGR\"] = \"com.fibaro.baseShutter\",\r\n    [\"com.fibaro.FGMS001\"] = \"com.fibaro.motionSensor\",\r\n    [\"com.fibaro.FGWP\"] = \"com.fibaro.binarySwitch\"\r\n}\r\n\r\nlocal fibaroTypeOverride = { \r\n    [\"com.fibaro.FGKF601\"] = \"com.fibaro.keyFob\",\r\n    [\"com.fibaro.FGD212\"] = \"com.fibaro.dimmer\",\r\n    [\"com.fibaro.FGMS001v2\"] = \"com.fibaro.motionSensor\",\r\n    [\"com.fibaro.FGFS101\"] = \"com.fibaro.floodSensor\",\r\n    [\"com.fibaro.FGWP102\"] = \"com.fibaro.binarySwitch\"\r\n}\r\n\r\nfunction cleanDeviceCache()\r\n    deviceHierarchy = { }\r\n    deviceNodeById = { }\r\n\r\n    allFibaroDevicesAmount = 0\r\n    filteredFibaroDevicesAmount = 0\r\n    identifiedHaEntitiesAmount = 0\r\nend\r\n\r\nfunction getDeviceHierarchyByFilter(customDeviceFilterJsonStr)\r\n    cleanDeviceCache()\r\n\r\n    deviceFilter = \r\n        {\r\n            filters = {\r\n                {\r\n                    filter = \"enabled\",\r\n                    value = { true }\r\n                },\r\n                {\r\n                    filter = \"visible\",\r\n                    value = { true }\r\n                }\r\n            }, \r\n            attributes = {\r\n                -- define the list of Fibaro device attributes we are interested in\r\n                main = {\r\n                    \"id\"\r\n                }\r\n            }\r\n        }\r\n\r\n    if (not isEmptyString(customDeviceFilterJsonStr)) then\r\n        print(\"\")\r\n        print(\"(!) Apply custom device filter: \" .. tostring(customDeviceFilterJsonStr))\r\n        print(\"--> It will only work if the provided filter is JSON like: \" .. \"{\\\"filter\\\":\\\"baseType\\\", \\\"value\\\":[\\\"com.fibaro.actor\\\"]},   {\\\"filter\\\":\\\"deviceID\\\", \\\"value\\\":[41,42]},   { MORE FILTERS MAY GO HERE }\")\r\n        print(\"--> See the list of Fibaro API filter types at https://manuals.fibaro.com/content/other/FIBARO_System_Lua_API.pdf => \\\"fibaro:getDevicesId(filters)\\\"\")\r\n        print(\"\")\r\n\r\n        local customDeviceFilterJson = json.decode(\"{ filters: [ \" .. customDeviceFilterJsonStr .. \"] }\") \r\n\r\n        shallowInsertTo(customDeviceFilterJson.filters, deviceFilter.filters)\r\n    end\r\n\r\n    print(\"Filter: \" .. json.encode(deviceFilter))\r\n\r\n    local allFibaroDevices = api.get(\"/devices\")\r\n    allFibaroDevicesAmount = #allFibaroDevices\r\n\r\n    local filteredFibaroDeviceIds = api.post( \r\n        \"/devices/filter\", \r\n        deviceFilter\r\n    )\r\n    filteredFibaroDevicesAmount = #filteredFibaroDeviceIds\r\n\r\n    ----------- BUILD FIBARO DEVICE HIERARCHY\r\n    for i=1, #allFibaroDevices do\r\n        appendNodeByFibaroDevice(allFibaroDevices[i], false)\r\n    end\r\n\r\n    -- DO PERFORMANCE HEAVY OPERATIONS ONLY FOR DEVICES THAT ARE IN FILTER SCOPE\r\n    for i=1, #filteredFibaroDeviceIds do\r\n        local fibaroDeviceId = filteredFibaroDeviceIds[i].id\r\n        local deviceNode = deviceNodeById[fibaroDeviceId]\r\n        local fibaroDevice = deviceNode.fibaroDevice\r\n        \r\n        ----------- INCLUDE NODE WITH DEVICE MATCHING FILTER CRITERIA\r\n        deviceNode.included = true\r\n\r\n        ----------- CREATE POWER, ENERGY & BATTERLY LEVEL SENSORS INSTEAD OF RELYING ON ATTRIBUTES WITHIN A SINGLE DEVICE\r\n        __checkAndAppendLinkedDevices(fibaroDevice)\r\n    end\r\n\r\n    __identifyDeviceHierarchy(deviceHierarchy)\r\n\r\n    return deviceHierarchy\r\nend\r\n\r\n----------- CREATE POWER, ENERGY & BATTERLY LEVEL SENSORS INSTEAD OF RELYING ON ATTRIBUTES WITHIN A SINGLE DEVICE\r\nfunction __checkAndAppendLinkedDevices(fibaroDevice)\r\n\r\n    -- Does device support energy monitoring? Create a dedicated sensor for Home Assistant\r\n    if (table_contains_value(fibaroDevice.interfaces, \"energy\")) then \r\n        local sensor = createLinkedMultilevelSensorDevice(fibaroDevice, \"energy\")\r\n\r\n        appendNodeByFibaroDevice(sensor, true)\r\n    end\r\n\r\n    -- Does device support power monitoring? Create a dedicated sensor for Home Assistant\r\n    if (table_contains_value(fibaroDevice.interfaces, \"power\")) then \r\n        local sensor = createLinkedMultilevelSensorDevice(fibaroDevice, \"power\")\r\n\r\n        appendNodeByFibaroDevice(sensor, true)\r\n    end\r\n\r\n\r\n    -- Battery powered device? Create a dedicated battery sensor for Home Assistant\r\n    if (table_contains_value(fibaroDevice.interfaces, \"battery\")) then\r\n        local sensor = createLinkedMultilevelSensorDevice(fibaroDevice, \"batteryLevel\")\r\n        appendNodeByFibaroDevice(sensor, true)\r\n    end\r\n\r\n    -- Is it a \"Remote Control\" device? Created dedicated devices for each combination of Button and Press Type\r\n    --if (device.type == RemoteController.type and device.subtype == RemoteController.subtype) then\r\n    if (RemoteController.isSupported(fibaroDevice)) then\r\n        if fibaroDevice.properties.centralSceneSupport then\r\n            for _, i in ipairs(fibaroDevice.properties.centralSceneSupport) do\r\n                for _, j in ipairs(i.keyAttributes) do\r\n                    local sensor = createLinkedKey(fibaroDevice, i.keyId, j)\r\n\r\n                    appendNodeByFibaroDevice(sensor, true)\r\n                end\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\nfunction appendNodeByFibaroDevice(fibaroDevice, included)\r\n    local fibaroDeviceId = fibaroDevice.id\r\n    local parentNode = deviceNodeById[fibaroDevice.parentId]\r\n\r\n    local node = {\r\n        id = fibaroDevice.id,\r\n\r\n        fibaroDevice = fibaroDevice,\r\n        identifiedHaEntity = nil,\r\n        identifiedHaDevice = nil,\r\n\r\n        parentNode = parentNode,\r\n\r\n        childNodeList = { },\r\n\r\n        included = included,\r\n\r\n        isHaDevice = false\r\n    }\r\n    deviceNodeById[fibaroDeviceId] = node\r\n\r\n    -- enrich with room name, base/type fixes, etc\r\n    if (not fibaroDevice.linkedDevice) then\r\n        enrichFibaroDeviceWithMetaInfo(node.fibaroDevice)\r\n    end\r\n\r\n    if parentNode then\r\n        table.insert(parentNode.childNodeList, node)\r\n    else\r\n        table.insert(deviceHierarchy, node)\r\n    end\r\n\r\n    return node\r\nend\r\n\r\nfunction getDeviceNodeById(fibaroDeviceId)\r\n    return deviceNodeById[fibaroDeviceId]\r\nend\r\n\r\n\r\nfunction removeDeviceNodeFromHierarchyById(id)\r\n    local deviceNode = deviceNodeById[id]\r\n    \r\n    local parentNode = deviceNode.parentNode\r\n    local sourceListForDeviceNode\r\n    \r\n    if parentNode then\r\n        sourceListForDeviceNode = parentNode.childNodeList\r\n    else\r\n        sourceListForDeviceNode = deviceHierarchy\r\n    end\r\n\r\n    local ind = table.indexOf(sourceListForDeviceNode, deviceNode)\r\n\r\n    if (ind) then\r\n        table.remove(sourceListForDeviceNode, ind)\r\n    else\r\n        print(\"WARNING: Device node \" .. id .. \" was not removed from cache\")\r\n    end\r\n\r\n    deviceNodeById[id] = nil\r\nend\r\n\r\nfunction createAndAddDeviceNodeToHierarchyById(id)\r\n    local fibaroDevice = api.get(\"/devices/\" .. id)\r\n\r\n    local status, deviceFilterById = pcall(clone, deviceFilter)\r\n    local filterOperands = deviceFilterById.filters\r\n    filterOperands[#filterOperands + 1] = {\r\n            filter = \"deviceID\",\r\n            value = { id }\r\n    }\r\n    \r\n    local filteredFibaroDeviceIds = api.post( \r\n        \"/devices/filter\", \r\n        deviceFilterById\r\n    )\r\n\r\n    local newFibaroDevice = api.get(\"/devices/\" .. id)\r\n    local newDeviceNode = appendNodeByFibaroDevice(newFibaroDevice)\r\n\r\n    if #filteredFibaroDeviceIds == 0 then\r\n        print(\"Device \" .. id .. \" doesn't match to filter criteria and thus skipped\") \r\n    else\r\n        newDeviceNode.included = true\r\n\r\n        __checkAndAppendLinkedDevices(newDeviceNode.fibaroDevice)\r\n\r\n        __identifyDeviceNode(newDeviceNode)\r\n    end\r\n\r\n    return newDeviceNode\r\nend\r\n\r\nfunction enrichFibaroDeviceWithMetaInfo(fibaroDevice)\r\n    -- OVERRIDE BASE TYPE IF NECESSARY\r\n    local overrideBaseType = fibaroBaseTypeOverride[fibaroDevice.baseType]\r\n    if overrideBaseType then \r\n        fibaroDevice.baseType = overrideBaseType\r\n    end\r\n\r\n    -- OVERRIDE TYPE IF NECESSARY\r\n    local overrideType = fibaroTypeOverride[fibaroDevice.type]\r\n    if overrideType then \r\n        fibaroDevice.type = overrideType\r\n    end\r\n\r\n    fibaroDevice.roomName = tostring(fibaro.getRoomNameByDeviceID(fibaroDevice.id))\r\n\r\n    return fibaroDevice\r\nend\r\n\r\nfunction PrototypeEntity.isSupported(fibaroDevice)\r\n    print(\"'isSupported' function is mandatory for implementation\")\r\nend\r\n\r\nfunction fibaroDeviceHasType(fibaroDevice, type)\r\n    return (fibaroDevice.baseType == type) or (fibaroDevice.type == type)\r\nend\r\n\r\nfunction fibaroDeviceHasNoType(fibaroDevice, type)\r\n    return not fibaroDeviceHasType(fibaroDevice, type)\r\nend\r\n\r\nfunction fibaroDeviceHasInterface(fibaroDevice, interface)\r\n    return table_contains_value(fibaroDevice.interfaces, interface)\r\nend\r\n\r\nfunction fibaroDeviceHasNoInterface(fibaroDevice, interface)\r\n    return not fibaroDeviceHasInterface(fibaroDevice, interface)\r\nend\r\n\r\n-----------------------------------\r\n-- HELPER FUNCTIONS - IDENTIFY DEVICE BRIDGE TYPE BY LOOKING AT FIBARO DEVICE TYPE\r\n-----------------------------------\r\n\r\nhaEntityTypeMappings = {\r\n    Switch, -- binary switch\r\n    Cover, -- multilevel switch\r\n    Light, -- binary light\r\n    Dimmer, -- multilevel light \r\n    Rgbw, -- multichannel and multilevel light\r\n    BinarySensor,\r\n    MultilevelSensor,\r\n    Thermostat,\r\n    RemoteController,\r\n    RemoteControllerKey\r\n}  \r\n\r\n-- *** REMOVE AND MERGE WITH DEVICE HIERARCHY DISCOVERY\r\nfunction __identifyDeviceHierarchy(deviceHierarchy)\r\n    for _, j in pairs(deviceHierarchy) do\r\n        __identifyDeviceNode(j)\r\n    end\r\nend\r\n\r\nfunction __identifyDeviceNode(deviceNode)\r\n    -- identify Home Assistant entity\r\n    if (deviceNode.included) then\r\n        -- *** REFACTOR TO REUSE IN A SIGNLE NODE DISCOVERY\r\n        local identifiedHaEntity = __identifyHaEntity(deviceNode)\r\n\r\n        if (identifiedHaEntity) then\r\n            deviceNode.identifiedHaEntity = identifiedHaEntity\r\n            identifiedHaEntitiesAmount = identifiedHaEntitiesAmount + 1\r\n        end\r\n    end\r\n\r\n    -- identify Home Assistant device\r\n    local haDevice\r\n    if (deviceNode.parentNode and deviceNode.parentNode.identifiedHaDevice ~= nil) then\r\n        haDevice = deviceNode.parentNode.identifiedHaDevice\r\n    elseif deviceNode.fibaroDevice.baseType == \"com.fibaro.device\" then\r\n        haDevice = identifyAndAppendHaDevice(deviceNode)\r\n    elseif deviceNode.identifiedHaEntity ~= nil then\r\n        haDevice = identifyAndAppendHaDevice(deviceNode)\r\n    else\r\n        -- no Home Assistant device association available\r\n    end\r\n    deviceNode.identifiedHaDevice = haDevice\r\n\r\n    -- identify child devices\r\n    for _, deviceChildNode in pairs(deviceNode.childNodeList) do\r\n        __identifyDeviceNode(deviceChildNode)\r\n    end\r\nend\r\n\r\nfunction __identifyHaEntity(deviceNode)\r\n    for i, j in ipairs(haEntityTypeMappings) do\r\n        if (j.isSupported(deviceNode.fibaroDevice)) then\r\n            return j:new(deviceNode)\r\n        end\r\n    end\r\n\r\n    return nul\r\nend\r\n\r\nfunction identifyAndAppendHaDevice(deviceNode)\r\n    local fibaroDevice = deviceNode.fibaroDevice\r\n\r\n    local haDevice = {\r\n        identifiers = \"hc3-\" .. fibaroDevice.id,\r\n        name = fibaroDevice.name,\r\n        suggested_area = fibaroDevice.roomName,\r\n        manufacturer = nil,\r\n        hw_version = nil,\r\n        sw_version = nil,\r\n        model = fibaroDevice.properties.model, \r\n        configuration_url = \"http://\" .. localIpAddress .. \"/app/settings/devices/list#device-\" .. fibaroDevice.id\r\n    }\r\n\r\n    if fibaroDeviceHasInterface(fibaroDevice, \"quickApp\") then\r\n        haDevice.hw_version = \"QuickApp (virtual device)\"\r\n        haDevice.sw_version = tostring(fibaroDevice.baseType) .. \"-\" .. tostring(fibaroDevice.type)\r\n    elseif fibaroDeviceHasInterface(fibaroDevice, \"zwave\") then\r\n        -- IDENTIFY HARDWARE VERSION\r\n        local zwaveHwVersion = fibaroDevice.properties.zwaveInfo\r\n        if zwaveHwVersion then\r\n            zwaveInfoComponents = splitStringToNumbers(zwaveHwVersion, \",\")\r\n            if (#zwaveInfoComponents == 3) then\r\n                zwaveHwVersion = \"Z-Wave type \" .. zwaveInfoComponents[1] .. \"; Z-Wave version \" .. zwaveInfoComponents[2] .. \".\" .. zwaveInfoComponents[3]\r\n            end\r\n        end\r\n        if zwaveHwVersion then\r\n            haDevice.hw_version = zwaveHwVersion\r\n        else   \r\n            haDevice.hw_version = \"Z-Wave\"\r\n        end\r\n        \r\n        -- IDENTIFY SOFTWARE VERSION\r\n        if fibaroDevice.properties.zwaveCompany then\r\n            haDevice.manufacturer = fibaroDevice.properties.zwaveCompany\r\n            haDevice.sw_version = haDevice.manufacturer .. \" \" .. tostring(fibaroDevice.properties.zwaveVersion)\r\n        else\r\n            haDevice.sw_version = tostring(fibaroDevice.properties.zwaveVersion)\r\n        end\r\n    elseif fibaroDeviceHasInterface(fibaroDevice, \"zigbee\") then\r\n        -- experimental, need hardware for testing\r\n        if fibaroDevice.properties.zigbeeVersion then\r\n            haDevice.hw_version = \"Zigbee\"\r\n        else\r\n            haDevice.hw_version = \"Zigbee \" .. fibaroDevice.properties.zigbeeVersion\r\n        end\r\n    elseif fibaroDeviceHasInterface(fibaroDevice, \"nice\") then\r\n        -- experimental, need hardware for testing\r\n        if fibaroDevice.properties.niceProtocol then\r\n            haDevice.hw_version = \"Nice \" .. fibaroDevice.properties.niceProtocol\r\n        else\r\n            haDevice.hw_version = \"Nice\"\r\n        end\r\n    end\r\n\r\n    deviceNode.isHaDevice = true\r\n\r\n    return haDevice\r\nend\r\n\r\n-- ****** FIX DEFECT => TOPIC FOR LINKED DEVICE\r\nfunction createLinkedMultilevelSensorDevice(fromDevice, linkedProperty)\r\n    local linkedUnit\r\n    if (linkedProperty == \"energy\") then\r\n        linkedUnit = \"kWh\"\r\n    elseif (linkedProperty == \"power\") then\r\n        linkedUnit = \"W\"\r\n    elseif (linkedProperty == \"batteryLevel\") then\r\n        linkedUnit = \"%\"\r\n    end\r\n\r\n    local newLinkedFibaroSensor = createLinkedFibaroDevice(fromDevice, linkedProperty, linkedUnit)\r\n\r\n    newLinkedFibaroSensor.baseType = \"com.fibaro.multilevelSensor\"\r\n    newLinkedFibaroSensor.type = \"com.fibaro.\" .. linkedProperty .. \"Sensor\"\r\n\r\n    return newLinkedFibaroSensor\r\nend\r\n\r\nfunction createLinkedKey(fromDevice, keyId, keyAttribute)\r\n    local keyAttribute = string.lower(keyAttribute)\r\n\r\n    local action = keyId .. \"-\" .. keyAttribute\r\n\r\n    --local newFibaroKey = createLinkedFibaroDevice(fromDevice, \"value\", nil)\r\n    local newFibaroKey = createLinkedFibaroDevice(fromDevice, action, nil)\r\n    newFibaroKey.baseType = \"com.alexander_vitishchenko.remoteKey\"\r\n    newFibaroKey.keyId = keyId\r\n    newFibaroKey.keyAttribute = keyAttribute\r\n\r\n    return newFibaroKey\r\nend\r\n\r\nfunction createLinkedFibaroDevice(fromDevice, linkedProperty, linkedUnit)\r\n    local newFibaroLinkedDevice = {\r\n        id = fromDevice.id .. \"_\" .. linkedProperty,\r\n        name = fromDevice.name,  \r\n        roomID = fromDevice.roomID,\r\n        roomName = fromDevice.roomName,\r\n        parentId = fromDevice.id,\r\n        linkedDevice = fromDevice,\r\n        linkedProperty = linkedProperty,\r\n        properties = {\r\n            unit = linkedUnit\r\n        },\r\n        comment = \"This entity has been autogenerated by HC3 <-> Home Assistant bridge to adjust the data model difference between Fibaro HC3 and Home Assistant. Fibaro treats '\" .. linkedProperty .. \"' entity to be an attribute of #\" .. fromDevice.id .. \". And Home Asisstant requires these to be two separate entities\"\r\n    }\r\n\r\n    return newFibaroLinkedDevice\r\nend\r\n\r\nfunction getDeviceDescriptionById(fibaroDeviceId)\r\n    local description = \"#\" .. tostring(fibaroDeviceId)\r\n\r\n    local deviceNode = getDeviceNodeById(fibaroDeviceId)\r\n\r\n    if deviceNode then\r\n        local fibaroDevice = deviceNode.fibaroDevice\r\n        if fibaroDevice then\r\n            description = description .. \" named as \" .. tostring(fibaroDevice.name) .. \" at \\\"\" .. tostring(fibaroDevice.roomName) .. \"\\\"\"\r\n        end\r\n    end\r\n\r\n    return description\r\nend\r\n"}]}

